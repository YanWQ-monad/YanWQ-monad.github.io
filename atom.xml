<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Monad&#39;s Blog</title>
  
  
  <link href="https://blog.monadx.com/atom.xml" rel="self"/>
  
  <link href="https://blog.monadx.com/"/>
  <updated>2023-07-02T06:16:15.945Z</updated>
  <id>https://blog.monadx.com/</id>
  
  <author>
    <name>Monad</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Write-up of COMPASS 2022 Summer Training</title>
    <link href="https://blog.monadx.com/2022/07/11/COMPASS-2022S/"/>
    <id>https://blog.monadx.com/2022/07/11/COMPASS-2022S/</id>
    <published>2022-07-11T02:00:00.000Z</published>
    <updated>2023-07-02T06:16:15.945Z</updated>
    
    <content type="html"><![CDATA[<p><del>SUSTech CTF 课堂开课啦！孩子机器老被打，多半是寄了，用 COMPASS 牌 CTF 暑期训练课程，练攻击，直接给他打回去，妈妈一定要记住哦！</del></p><p>咳咳，总之这篇就是 SUSTech COMPASS 暑期 CTF 训练的题解（非官方）。</p><span id="more"></span><h1 id="目录">目录</h1><ul><li><a href="#week-1">Week 1</a><ul><li><a href="#practice-flag">Practice Flag</a></li><li><a href="#where-can-my-robot-go">Where Can My Robot Go?</a></li><li><a href="#wikipedia">Wikipedia</a></li><li><a href="#进制十六参上">进制十六——参上</a></li><li><a href="#猫咪问答-pro-max">猫咪问答 Pro Max</a></li><li><a href="#旅行照片">旅行照片</a></li><li><a href="#卖瓜">卖瓜</a></li><li><a href="#fixme1.py">fixme1.py</a></li><li><a href="#fixme2.py">fixme2.py</a></li><li><a href="#pw-crack-1">PW Crack 1</a></li><li><a href="#pw-crack-2">PW Crack 2</a></li><li><a href="#pw-crack-3">PW Crack 3</a></li><li><a href="#pw-crack-4">PW Crack 4</a></li><li><a href="#pw-crack-5">PW Crack 5</a></li><li><a href="#time-traveller">Time Traveller</a></li><li><a href="#command-challenge">Command Challenge</a></li></ul></li><li><a href="#week-2">Week 2</a><ul><li><a href="#web-签到题">web 签到题</a></li><li><a href="#basic-injection">Basic Injection</a></li><li><a href="#post-practice">POST Practice</a></li><li><a href="#dont-bump-your-header">Don't Bump Your Head(er)</a></li><li><a href="#calculat3-m3">Calculat3 M3</a></li><li><a href="#php-audit">php audit</a></li><li><a href="#execute">Execute?</a></li><li><a href="#why-sqli">why sqli?</a></li></ul></li><li><a href="#week-3">Week 3</a><ul><li><a href="#whats-my-ip-address">What's my IP address?</a></li><li><a href="#flag-助力大红包">FLAG 助力大红包</a></li><li><a href="#sqli">SQLI</a></li><li><a href="#simple-sqli">Simple SQLI</a></li><li><a href="#not-easy-sql-injection">Not easy SQL injection</a></li><li><a href="#reverse-shell-included">Reverse shell included</a></li><li><a href="#php-pop">PHP POP</a></li></ul></li><li><a href="#week-4">Week 4</a><ul><li><a href="#information">Information</a></li><li><a href="#matryoshka-doll">Matryoshka doll</a></li><li><a href="#like1000">like1000</a></li><li><a href="#upper-lower-case">upper-lower case</a></li><li><a href="#whitepages">WhitePages</a></li><li><a href="#sleuthkit-apprentice">Sleuthkit Apprentice</a></li><li><a href="#m00nwalk">m00nwalk</a></li><li><a href="#weak-password">weak password</a></li><li><a href="#简单的隐写">简单的隐写</a></li></ul></li></ul><h1 id="week-1">Week 1</h1><h2 id="practice-flag">Practice Flag</h2><p>直接把 "Try inputting the flag:" 后面的 flag 复制粘贴就可以了。</p><h2 id="where-can-my-robot-go">Where Can My Robot Go?</h2><p>robots.txt 是放在网站根目录下的一个文件，用来告诉搜索引擎或者爬虫哪些内容能访问，哪些不能（不过这不是强制的）。详情可以去 Google "robots.txt"。</p><p>然后这道题的话，我们就访问一下这个 robots.txt 文件（<a href="https://ctflearn.com/robots.txt">https://ctflearn.com/robots.txt</a>），然后可以找到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow: /70r3hnanldfspufdsoifnlds.html</span><br></pre></td></tr></tbody></table></figure><p>这里有一个非常奇怪的网页，<del>虽然写了 Disallow</del>，我们就点进去看一下（<a href="https://ctflearn.com/70r3hnanldfspufdsoifnlds.html">https://ctflearn.com/70r3hnanldfspufdsoifnlds.html</a>），于是就发现了 flag。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTFlearn{r0b0ts_4r3_th3_futur3}</span><br></pre></td></tr></tbody></table></figure><h2 id="wikipedia">Wikipedia</h2><p>说到 Wikipedia，一般指的是英文的维基百科，即 <a href="https://en.wikipedia.org">https://en.wikipedia.org</a>。</p><p>然后 IP 的话，一般会出现在 Wikipedia 的修改历史里面。因为 Wikipedia 是允许非注册用户对页面进行修改的，这时候就会用 IP 来代替用户名。</p><p>现在的问题就变成了如何在 Wikipedia 找到这个 IP 的修改记录，毕竟现在也不知道怎么查。我们就可以随便找一个页面（比如主页），点右上角的 View history，翻一下页，找到一个用 IP 的修改记录；并且发现，点击 IP，弹出的页面就是这个 IP 的所有修改记录。</p><p>然后不难发现，此时的 URL 是 <code>https://en.wikipedia.org/wiki/Special:Contributions/&lt;IP&gt;</code> 的形式，把 <code>&lt;IP&gt;</code> 换成我们想查的 IP，即 <a href="https://en.wikipedia.org/wiki/Special:Contributions/128.125.52.138">https://en.wikipedia.org/wiki/Special:Contributions/128.125.52.138</a>。</p><p>点开这个链接，发现只有一条修改记录，点击 "diff"（即查看这次修改修改了啥），发现了这么个玩意：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Wikipedia_Flag.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Wikipedia_Flag.png" loading="lazy"></a></p><p>然后这玩意就是 flag 了。</p><h2 id="进制十六参上">进制十六——参上</h2><p>见 Hackergame 2021 题解的<a href="/2021/10/31/Hackergame-2021/#进制十六参上">进制十六——参上</a>。</p><h2 id="猫咪问答-pro-max">猫咪问答 Pro Max</h2><p>见 Hackergame 2021 题解的<a href="/2021/10/31/Hackergame-2021/#猫咪问答-pro-max">猫咪问答 Pro Max</a>。</p><h2 id="旅行照片">旅行照片</h2><p>见 Hackergame 2021 题解的<a href="/2021/10/31/Hackergame-2021/#旅行照片">旅行照片</a>。</p><h2 id="卖瓜">卖瓜</h2><p>见 Hackergame 2021 题解的<a href="/2021/10/31/Hackergame-2021/#卖瓜">卖瓜</a>。</p><h2 id="fixme1.py">fixme1.py</h2><p>把文件下载下来，先跑一下（不跑怎么知道它错在了哪里呢）。然后 Python 就报错：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python3 fixme1.py</span><br><span class="line">  File "~/Downloads/fixme1.py", line 20</span><br><span class="line">    print('That is correct! Here\'s your flag: ' + flag)</span><br><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></tbody></table></figure><p>就是这个地方缩进不对：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = str_xor(flag_enc, <span class="string">'enkidu'</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'That is correct! Here\'s your flag: '</span> + flag)</span><br></pre></td></tr></tbody></table></figure><p>按照脚本的意思（毕竟这附近也没有 if 什么的控制语句嘛），所以把 <code>print</code> 前面那俩空格删了就可以了。然后重新跑一下就能出 flag 了。</p><h2 id="fixme2.py">fixme2.py</h2><p><del>按照惯例</del>，先跑一下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3 fixme2.py</span><br><span class="line">  File "/Users/monad/Downloads/fixme2.py", line 22</span><br><span class="line">    if flag = "":</span><br><span class="line">            ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></tbody></table></figure><p><del>经典用单个等于判断相等</del>，把 <code>=</code> 改成 <code>==</code> 就 ok 了。</p><h2 id="pw-crack-1">PW Crack 1</h2><p><del>按照惯例</del>，先跑一下，然后发现要输入密码。然后打开源代码看一下，发现了这么个玩意：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_pw = <span class="built_in">input</span>(<span class="string">"Please enter correct password for flag: "</span>)</span><br><span class="line"><span class="keyword">if</span>( user_pw == <span class="string">"1e1a"</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome back... your flag, user:"</span>)</span><br></pre></td></tr></tbody></table></figure><p>所以 <code>1e1a</code> 就肯定是密码了，于是输入进去，就出 flag 了。</p><h2 id="pw-crack-2">PW Crack 2</h2><p>这道题跟上一题差不多：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_pw = <span class="built_in">input</span>(<span class="string">"Please enter correct password for flag: "</span>)</span><br><span class="line"><span class="keyword">if</span>( user_pw == <span class="built_in">chr</span>(<span class="number">0x33</span>) + <span class="built_in">chr</span>(<span class="number">0x39</span>) + <span class="built_in">chr</span>(<span class="number">0x63</span>) + <span class="built_in">chr</span>(<span class="number">0x65</span>) ):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Welcome back... your flag, user:"</span>)</span><br></pre></td></tr></tbody></table></figure><p>你可以把 <code>chr(0x33) + chr(0x39) + chr(0x63) + chr(0x65)</code> 喂给 Python 看看是多少（然后就跟上一题一样了）。如果想偷懒的话，可以直接改成：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">user_pw = chr(0x33) + chr(0x39) + chr(0x63) + chr(0x65)</span><br><span class="line">if( user_pw == chr(0x33) + chr(0x39) + chr(0x63) + chr(0x65) ):</span><br><span class="line">    print("Welcome back... your flag, user:")</span><br></pre></td></tr></tbody></table></figure><p>跑一下就能出 flag。</p><h2 id="pw-crack-3">PW Crack 3</h2><p>朴素方法：把 <code>pos_pw_list</code> 里面的每个密码都试一次，看看哪个对。</p><p>更优的方法：看下一题。</p><h2 id="pw-crack-4">PW Crack 4</h2><p>由于这道题的可能的密码的数量非常多，高达 100 个，手动试就太慢了（事实上在上一题试 7 个我都已经不想试了）。</p><p>于是我们就可以手动魔改代码，用程序来帮我们试。其实就是把下面的部分改成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">level_4_pw_check</span>(<span class="params">password</span>):  <span class="comment"># 通过参数传入密码</span></span><br><span class="line">    user_pw = password</span><br><span class="line">    user_pw_hash = hash_pw(user_pw)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> user_pw_hash == correct_pw_hash:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Welcome back... your flag, user:"</span>)</span><br><span class="line">        decryption = str_xor(flag_enc.decode(), user_pw)</span><br><span class="line">        <span class="built_in">print</span>(decryption)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">pos_pw_list = ...  <span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有可能的密码</span></span><br><span class="line"><span class="keyword">for</span> password <span class="keyword">in</span> pos_pw_list:</span><br><span class="line">    level_4_pw_check(password)</span><br></pre></td></tr></tbody></table></figure><p>然后跑一下，就 ok 了。</p><h2 id="pw-crack-5">PW Crack 5</h2><p>这道题跟上一题的相似度，比上一题跟上上一题的还高，只是这题的密码表存到了另外一个文件里，并且是真的多。</p><p>跟上一题类似，把代码魔改成：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">'dictionary.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 可以用 for in 的方法来遍历文件的每一行</span></span><br><span class="line">    <span class="keyword">for</span> password <span class="keyword">in</span> f:</span><br><span class="line">        <span class="comment"># 这里用 .strip() 去除每一行末尾的空格</span></span><br><span class="line">        level_5_pw_check(password.strip())</span><br></pre></td></tr></tbody></table></figure><p>然后跑一跑就能出 flag。</p><h2 id="time-traveller">Time Traveller</h2><p>这道题大意就是让我们在 1996 年 12 月 31 日的 NASA（<del>由崎&nbsp;<ruby>星<rp>(</rp><rt>ナ</rt><rp>)</rp>空<rp>(</rp><rt>サ</rt><rp>)</rp></ruby></del>）的官网上面找到一个电子邮件。</p><p>与互联网上的旧页面相关的，一律找 <a href="https://web.archive.org">Internet Archive</a>。</p><p>首先不难发现，NASA 的官网是 https://www.nasa.gov，把它扔到上面的 Internet Archive 网站里面，找到 1996 年 12 月 31 日的页面：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/NASA_Dec_31_1996.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/NASA_Dec_31_1996.png" loading="lazy"></a></p><p>不难发现邮箱 <code>today@nasa.gov</code>。</p><h2 id="command-challenge">Command Challenge</h2><p><del>朴素方法：一道一道题做下去，就能拿到 flag，顺便还能学到不少 Linux bash 的技巧。</del></p><p>首先先过个一两题，然后打开 F12，发现通过的题目是存在本地的：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_storage.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_storage.png" loading="lazy"></a></p><p>于是就可以想着去修改它，来“快速过题”。于是现在的问题就是，如何找到题目的列表，然后填上去。</p><p>用 <code>current_working_directory</code> 在前端的文件里面搜索，然后就可以找到一个很像配置文件的配置文件：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_configuration.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_configuration.png" loading="lazy"></a></p><p>这里的话，其实每个 <code>slug</code> 后面跟的字符串，就是题目的名字。</p><blockquote><p>有同学说用 <code>ls ..</code>（列出上级目录的文件）也可以得到题目的列表。</p></blockquote><p>我们把它们收集起来，然后扔到上面的 <code>correct_answers</code>，再刷新一下页面：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_solved.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Command_Challenge_solved.png" loading="lazy"></a></p><p>就发现前面多了一行 <code>🎉.....🎉</code> 的庆祝语，连着两个 emoji 复制，粘贴，就可以过了。</p><h1 id="week-2">Week 2</h1><h2 id="web-签到题">web 签到题</h2><p>打开网站，发现啥都没有（指可交互元素），然后查看 HTML 源代码，发现：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where is flag?</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">Y3Rmc2hvd3s0YmY1M2U3MC02YzM2LTRiYjEtOWNhMS1jOTc5OGQ5NWY0MGZ9--&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>然后发现一串神秘字符串。用一种常见的字符串编码方式（即 base64）解码，就可以得到 flag。</p><h2 id="basic-injection">Basic Injection</h2><p>构造 <code>' or 1=1; -- a</code>，让最终的查询变成 <code>SELECT * FROM webfour.webfour where name = '' or 1=1; -- a'</code>（实际上等价于 <code>SELECT * FROM webfour.webfour</code>），就可以查询所有记录了。</p><p>然后发现查询的结果里面就有 flag。</p><blockquote><p>值得注意的是，<code>--</code> 使注释生效的一个条件是，<code>--</code> 后面必须要有一个空格。如果要避免两端空格被吞掉的话，可以在后面补一个字符。</p></blockquote><h2 id="post-practice">POST Practice</h2><p>惯例，先直接访问一下。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/POST_Practice_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/POST_Practice_1.png" loading="lazy"></a></p><p>唔……它告诉说需要 POST 某些东西才可以。不过内容都在注释里面写着了。</p><p>我们就直接 POST 给服务器就好了。</p><blockquote><p>发送 POST 请求可以用 Postman 等图形化应用，也可以手动调用 curl。</p></blockquote><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/POST_Practice_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/POST_Practice_2.png" loading="lazy"></a></p><p>于是我们就摸到了 flag。</p><h2 id="dont-bump-your-header">Don't Bump Your Head(er)</h2><p>按照惯例，先访问一下网站：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_1.png" loading="lazy"></a></p><p>虽然没有明说，但是可以试试把 <code>Sup3rS3cr3tAg3nt</code> 作为 <code>User-Agent</code> 发送给服务器。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_2.png" loading="lazy"></a></p><p>这时候，它告诉我们说，你不是来自 <code>awesomesauce.com</code> 这个服务器。</p><p>HTTP headers 里面有一个叫 <code>Referer</code> 的东西，可以向服务器表示我是从哪个网页跳转过来的，这一条也可以瞎搞，改成服务器想要的就行了。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_3.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Bump_Header_3.png" loading="lazy"></a></p><p>然后就拿到了 flag。</p><h2 id="calculat3-m3">Calculat3 M3</h2><p>先随便输入一个算式，然后发个请求，看看它是怎么算的。可以发现，它发了一个 POST 请求，内容是 <code>express=3+3</code>（虽然其实还有空格，不过问题不大）。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Calculat3_M3_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Calculat3_M3_1.png" loading="lazy"></a></p><p>然后这里怎么注入呢，比如说，它有可能是执行命令 <code>calc 3+3</code>，然后把它的输出返回。这时候，如果网页的防护不强，我们就可以在 <code>3+3</code> 的后面再塞点东西，让他执行其它命令。</p><p>比如说，如果我们给它一个 <code>3+3; ls</code>，拼起来之后就是 <code>calc 3+3; ls</code>，这样的话，除了执行 <code>calc 3+3</code> 之外，它还会执行 <code>ls</code>（列出当前目录下的文件）。把 <code>ls</code> 换成其它命令，就可以随便乱搞了。</p><p>于是这里我们先给它发一个 <code>3; ls</code> 看看：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Calculat3_M3_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Calculat3_M3_2.png" loading="lazy"></a></p><p>运气不错，拿到 flag 了。</p><blockquote><p><del>我也不知道为什么 <code>3 + 3; ls</code> 不行，只能说服务器十分的玄学，甚至除了 <code>ls</code> 之外的命令都用不了。可能它只是特判了一下一些特殊的模式，然后就给你返回了，实际上并没有真正的执行命令。</del></p></blockquote><h2 id="php-audit">php audit</h2><p>按照惯例，先访问一下，获得了 PHP 源代码：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">include</span> <span class="string">"flag1.php"</span>;</span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(__file__);</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">'args'</span>])){</span><br><span class="line">    <span class="variable">$args</span> = <span class="variable">$_GET</span>[<span class="string">'args'</span>];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">"/^\w+$/"</span>,<span class="variable">$args</span>)){</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">"args error!"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">eval</span>(<span class="string">"var_dump($<span class="subst">$args</span>);"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然我不怎么会 PHP，但是能够感觉得出来，你在 <code>args</code> 传入什么，它就会把哪个变量打印出来。比如说如果传入参数 <code>args=$_GET</code>，它就会把 <code>_GET</code> 里面的东西打印出来。</p><p>然后由于这里限制了 <code>args</code> 只能是大小写字母、数字、下划线，所以执行恶意代码是几乎不可能的了。</p><p>所以打印变量的话，我们可以考虑 PHP 的一些特殊的、内置的变量（好像在官方文档里面叫做<a href="https://www.php.net/manual/zh/reserved.variables.php">预定义变量</a>）。翻一下文档，发现一个不错的 <code>$GLOBALS</code>，可以打印出全局的全部变量。</p><p>废话少说，直接试试：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/PHP_audit.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/PHP_audit.png" loading="lazy"></a></p><p>于是我们就获得了 flag。</p><blockquote><p>源代码里面的 <code>$$args</code> 是什么意思，可以看官方文档的 <a href="https://www.php.net/manual/en/language.variables.variable.php">Variable variables</a>。</p></blockquote><h2 id="execute">Execute?</h2><p>开始先和 <a href="#calculat3-m3">Calculat3 M3</a> 差不多，先随便输入一个 IP 看看它是怎么发送请求的。然后发现它是给 <code>http://103.102.44.218:10016/exec.php?ip=&lt;ip&gt;</code> 发送了请求（其中 <code>&lt;ip&gt;</code> 即指某个具体 IP）。</p><p>然后 F12 看一下，发现可以访问 <code>/exec.php?view_source</code> 来获取源代码，可以看到它过滤了包括但不限于 <code>&amp;</code>, <code>|</code>, <code>`</code> 字符。</p><blockquote><p>其实说实话，我做这道题的时候没发现这个源代码，<del>不过还是做出来了</del>，还是顺便讲讲吧。</p><p>瞎试一下，发现传 <code>"127.0.0.1"</code>（带双引号），它也可以正常工作。不过这并不能说明它没过滤双引号（虽然事实上确实没有）。</p><p>然后继续瞎试，在双引号里面带个空格试试，传个 <code>"127.0.0.1 abc"</code>，发现它还是正常的：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_try_space.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_try_space.png" loading="lazy"></a></p><p>于是发现 <code>ping</code> 指会取空格前面的 IP，后面的是不管的。不过显示的时候还是会全部显示出来。于是就可以用这个方法试试哪些字符能用，就是瞎滚键盘，看看它返回了哪些字符，就说明哪些没被过滤。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_filter_table.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_filter_table.png" loading="lazy"></a></p><p>然后就曲线救国地也把过滤的字符集也挖了出来。</p></blockquote><p>由于它过滤了 <code>&amp;</code>, <code>|</code>, <code>`</code> 等字符，一般的注入方式没办法使用（指 <code>&amp;&amp; ls</code>, <code>`ls`</code>, <code>${ls}</code> 等）。</p><p>不过还有一个老旧的方法可以试试，就是用换行。于是发一个请求 <code>127.0.0.1\nls</code>（在这里，<code>\n</code> 表示换行）。Surprise, it works.</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_ls.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_ls.png" loading="lazy"></a></p><p>然后发现 <code>flag.php</code> 后，<code>cat</code> 一下就能拿到它的内容，里面就有 flag。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_solved.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Execute_solved.png" loading="lazy"></a></p><h2 id="why-sqli">why sqli?</h2><p>先请求一下，拿到代码。（下面的代码简化了一下，保留了核心部分。）</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'db.inc.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params"><span class="variable">$str</span></span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">get_magic_quotes_gpc</span>()) {</span><br><span class="line">        <span class="variable">$str</span> = <span class="title function_ invoke__">stripslashes</span>(<span class="variable">$str</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">htmlentities</span>(<span class="variable">$str</span>, ENT_QUOTES);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$username</span> = @<span class="title function_ invoke__">clean</span>((<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">'username'</span>]);</span><br><span class="line"><span class="variable">$password</span> = @<span class="title function_ invoke__">clean</span>((<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">'password'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$query</span> = <span class="string">'SELECT * FROM users WHERE name=\''</span>.<span class="variable">$username</span>.<span class="string">'\' AND pass=\''</span>.<span class="variable">$password</span>.<span class="string">'\';'</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$result</span> || <span class="title function_ invoke__">mysql_num_rows</span>(<span class="variable">$result</span>) &lt; <span class="number">1</span>) {</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">'Invalid password!'</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_assoc</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Hello "</span>.<span class="variable">$row</span>[<span class="string">'name'</span>].<span class="string">"&lt;/br&gt;Your password is:"</span>.<span class="variable">$row</span>[<span class="string">'pass'</span>].<span class="string">"&lt;/br&gt;"</span>;</span><br></pre></td></tr></tbody></table></figure><p>可以看到两个参数 <code>username</code> 和 <code>password</code> 都做了过滤。翻一下 PHP 文档，发现 <code>get_magic_quotes_gpc()</code> 永远返回 false，所以这个 <code>if</code> 就不用管了，只需要看 <code>htmlentities</code> 就可以了。</p><p><code>htmlentities</code> 在第二个参数传入 <code>ENT_QUOTES</code> 的时候，会对 <code>$str</code> 的单、双引号进行转义，具体为 <code>"</code> 转成 <code>&amp;quot;</code>，<code>'</code> 转成 <code>&amp;#039;</code>。思索一下，感觉绕过 <code>htmlentities</code> 来传入引号有点困难，看看有没有别的路可以走。</p><p><del>不难发现</del>，<code>htmlentities</code> 没有处理 <code>\</code> 反斜杠，如果在 <code>username</code> 里面传入 <code>\</code> 的话，SQL 就会变成</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">'\'</span> <span class="keyword">AND</span> pass<span class="operator">=</span><span class="string">'&lt;password&gt;'</span>;</span><br></pre></td></tr></tbody></table></figure><p><del>这个高亮好像有点问题，它没有处理 <code>\</code></del>。然后就发现，它变成了 <code>name</code> 跟 <code>' AND pass=</code> 做比较，然后后面 <code>&lt;password&gt;</code> 的地方就可以随便注了。后面多余的那个单引号用注释干掉就可以了</p><p>比如我们可以来一个 <code>password</code> 为 <code>or 1=1; -- a</code>，就可以构造这么一个 SQL：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">'\" AND pass='</span> <span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span>; <span class="comment">-- a';</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>因为这个高亮确实不太行，所以这里我把 <code>\'</code> 换成 <code>\"</code> 来让它正确高亮了，实际上还是单引号的。</p></blockquote><p>然后把这个请求扔上去，就发现它确实绕过去了：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Why_sqli_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Why_sqli_1.png" loading="lazy"></a></p><p>不过……这个好像不是 flag？</p><p>唔……那就查查另外几行吧。（如果还是不行的话，后面还可以用 <code>UNION SELECT</code> 对数据库进行全面的扒取。）</p><p>用 <code>LIMIT 1 OFFSET x</code> 查查另外几行，然后在试到第三行的时候（即 <code>LIMIT 1 OFFSET 2</code>），发现 flag：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Why_sqli_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Why_sqli_2.png" loading="lazy"></a></p><h1 id="week-3">Week 3</h1><h2 id="whats-my-ip-address">What's my IP address?</h2><p>直接访问，然后获得 PHP 源代码（下面的代码是稍微格式化过的）。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"flag.php"</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetIP</span>(<span class="params"></span>)</span>{</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$_SERVER</span>[<span class="string">"HTTP_CLIENT_IP"</span>]))</span><br><span class="line">    <span class="variable">$cip</span> = <span class="variable">$_SERVER</span>[<span class="string">"HTTP_CLIENT_IP"</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$_SERVER</span>[<span class="string">"HTTP_X_FORWARDED_FOR"</span>]))</span><br><span class="line">    <span class="variable">$cip</span> = <span class="variable">$_SERVER</span>[<span class="string">"HTTP_X_FORWARDED_FOR"</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">empty</span>(<span class="variable">$_SERVER</span>[<span class="string">"REMOTE_ADDR"</span>]))</span><br><span class="line">    <span class="variable">$cip</span> = <span class="variable">$_SERVER</span>[<span class="string">"REMOTE_ADDR"</span>];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="variable">$cip</span> = <span class="string">"0.0.0.0"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable">$cip</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$GetIPs</span> = <span class="title function_ invoke__">GetIP</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$GetIPs</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$GetIPs</span> == <span class="string">"1.1.1.1"</span>){</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Great! Key is <span class="subst">$flag</span>"</span>;</span><br><span class="line">} <span class="keyword">else</span>{</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"Error! Your IP address isn't in the legal range!"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="title function_ invoke__">show_source</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>具体逻辑就是先后尝试从 <code>_SERVER</code> 的 <code>HTTP_CLIENT_IP</code>, <code>HTTP_X_FORWARDED_FOR</code>, <code>REMOTE_ADDR</code> 取 IP 地址，然后再跟 <code>1.1.1.1</code> 比较，相等则给出 flag。</p><p>想要真实地从 <code>1.1.1.1</code> 发送请求，有亿点困难（<del>可能可以 py Cloudflare？</del>）。不过好消息是，<code>HTTP_CLIENT_IP</code> 和 <code>HTTP_X_FORWARDED_FOR</code> 都是可以伪造的（<code>REMOTE_ADDR</code> 不能伪造）。<code>HTTP_CLIENT_IP</code> 是从 HTTP headers 的 <code>Client-IP</code> 取值，<code>HTTP_X_FORWARDED_FOR</code> 从 <code>X-Forwarded-For</code> 取值。</p><p>然后手动设置这两个的其中一个，再请求一下，就可以了。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Whats_my_IP_address.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Whats_my_IP_address.png" loading="lazy"></a></p><h2 id="flag-助力大红包">FLAG 助力大红包</h2><p>跟上一题差不多，不过要用 <code>X-Forwarded-For</code>。（<code>Client-IP</code> 没试过，不知道行不行。）</p><p>详情见 Hackergame 2021 题解的 <a href="/2021/10/31/Hackergame-2021/#flag-助力大红包">FLAG 助力大红包</a>。</p><h2 id="sqli">SQLI</h2><p>首先先直接访问，发现页面上有一句 "source file in web9.php.bak"。访问这个页面，获得 PHP 源代码（下面的代码也是稍微格式化过的）。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">"user"</span>];</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">"pass"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"select pw from php where user='<span class="subst">$user</span>'"</span>;</span><br><span class="line"><span class="variable">$query</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable">$query</span>) {</span><br><span class="line">  <span class="title function_ invoke__">printf</span>(<span class="string">"Error: %s\n"</span>, <span class="title function_ invoke__">mysql_error</span>(<span class="variable">$conn</span>));</span><br><span class="line">  <span class="keyword">exit</span>();</span><br><span class="line">}</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$query</span>, MYSQL_ASSOC);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="variable">$row</span>[<span class="string">"pw"</span>]) &amp;&amp; (!<span class="title function_ invoke__">strcasecmp</span>(<span class="variable">$pass</span>, <span class="variable">$row</span>[<span class="string">"pw"</span>]))) {</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;p&gt;Logged in! Key:************** &lt;/p&gt;"</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;p&gt;Log in failure!&lt;/p&gt;"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>大概需要提前说明的一点是，这道题的 flag 不在数据库里面，如果直接硬注数据库的话，也能拿到 flag，但不是这道题的 flag。</p><p>实际上，flag 在 <code>Key: **************</code> 这个地方，虽然“备份文件”把它模糊掉了，实际上运行的代码是有的。</p></blockquote><p>这里的话，如果要让他成功输出 <code>Key</code>，那就需要让那条 <code>if</code> 判断为 <code>true</code>，即需要让 <code>$pass</code> 和 <code>$row["pw"]</code> 相等。其中 <code>$pass</code> 是可控的，比如说我们传入 <code>pass=a</code>，那么 <code>$pass</code> 就是 <code>0cc175b9c0f1b6a831c399e269772661</code>（<code>a</code> 的 MD5）。如果我们能让从数据库查出来的 <code>$row["pw"]</code> 跟 <code>0cc175b9c0f1b6a831c399e269772661</code> 相等，就可以了。</p><p>然后 <code>$user</code> 没有任何过滤，直接用 <code>UNION SELECT</code> 注入就可以了。令 <code>user</code> 为 <code>' UNION SELECT '0cc175b9c0f1b6a831c399e269772661'; -- a</code>，执行的 SQL 就是：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pw <span class="keyword">from</span> php <span class="keyword">where</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">''</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="string">'0cc175b9c0f1b6a831c399e269772661'</span>; <span class="comment">-- a'</span></span><br></pre></td></tr></tbody></table></figure><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/SQLI.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/SQLI.png" loading="lazy"></a></p><p>然后就拿到了 flag。</p><h2 id="simple-sqli">Simple SQLI</h2><p>首先先直接访问，感觉 UI 好像跟上一题差不多，并且 F12 发现注释里有一句 "web11.php.bak"。访问这个页面，获得 PHP 源代码（下面的代码也是稍微格式化过的，并且删掉了一些无关紧要的部分）。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"../web9/db.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$user</span> = <span class="variable">$_POST</span>[<span class="string">"user"</span>];</span><br><span class="line"><span class="variable">$pass</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$_POST</span>[<span class="string">"pass"</span>]);</span><br><span class="line"></span><br><span class="line"><span class="variable">$sql</span> = <span class="string">"select user from php where (user='<span class="subst">$user</span>') and (pw='<span class="subst">$pass</span>')"</span>;</span><br><span class="line"><span class="variable">$query</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_array</span>(<span class="variable">$query</span>, MYSQL_ASSOC);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$row</span>[<span class="string">"user"</span>] == <span class="string">"admin"</span>) {</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"&lt;p&gt;Logged in! Key: *********** &lt;/p&gt;"</span>;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="keyword">echo</span>(<span class="string">"&lt;p&gt;You are not admin!&lt;/p&gt;"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这道题注起来似乎比上一题还简单，因为 <code>$user</code> 就是一个十分可控的注入点。直接令 <code>user</code> 为 <code>admin'); -- a</code>，就能拼出这么个查询 SQL：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> php <span class="keyword">where</span> (<span class="keyword">user</span><span class="operator">=</span><span class="string">'admin'</span>); <span class="comment">-- a') and (pw='$pass')</span></span><br></pre></td></tr></tbody></table></figure><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Simple_SQLI.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Simple_SQLI.png" loading="lazy"></a></p><p>然后就能获得 flag 了。连 <code>pass</code> 都不用管。</p><h2 id="not-easy-sql-injection">Not easy SQL injection</h2><p>直接访问，然后获得 PHP 源代码（下面的代码是稍微格式化过的）。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment"># $yourInfo=array(</span></span><br><span class="line"><span class="comment">#   'id'    =&gt; 1,</span></span><br><span class="line"><span class="comment">#   'name'  =&gt; 'admin',</span></span><br><span class="line"><span class="comment">#   'pass'  =&gt; 'xxx',</span></span><br><span class="line"><span class="comment">#   'level' =&gt; 1</span></span><br><span class="line"><span class="comment"># );</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">'db.inc.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$_CONFIG</span>[<span class="string">'extraSecure'</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">array</span>(<span class="string">'_GET'</span>, <span class="string">'_POST'</span>, <span class="string">'_REQUEST'</span>, <span class="string">'_COOKIE'</span>) <span class="keyword">as</span> <span class="variable">$method</span>) {</span><br><span class="line">  <span class="keyword">foreach</span> (<span class="variable">$$method</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>) {</span><br><span class="line">    <span class="keyword">unset</span>(<span class="variable">$$key</span>);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$kw</span> = <span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">'kw'</span>]) ? <span class="title function_ invoke__">trim</span>(<span class="variable">$_GET</span>[<span class="string">'kw'</span>]) : <span class="keyword">die</span>(<span class="string">'Please enter in a search keyword.'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_CONFIG</span>[<span class="string">'extraSecure'</span>]) {</span><br><span class="line">  <span class="variable">$kw</span> = <span class="title function_ invoke__">preg_replace</span>(<span class="string">'#[^a-z0-9_-]#i'</span>,<span class="string">''</span>,<span class="variable">$kw</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$query</span> = <span class="string">'SELECT * FROM messages WHERE message LIKE \'%'</span>.<span class="variable">$kw</span>.<span class="string">'%\';'</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">mysql_query</span>(<span class="variable">$query</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">mysql_errno</span>()) <span class="keyword">die</span>(<span class="title function_ invoke__">mysql_error</span>());</span><br><span class="line"><span class="variable">$row</span> = <span class="title function_ invoke__">mysql_fetch_assoc</span>(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"id: "</span>.<span class="variable">$row</span>[<span class="string">'id'</span>].<span class="string">"&lt;/br&gt;message: "</span>.<span class="variable">$row</span>[<span class="string">'message'</span>].<span class="string">"&lt;/br&gt;"</span>;</span><br></pre></td></tr></tbody></table></figure><p>首先就是那两个 <code>foreach</code>，由于用了一些炫酷的语法糖所以可能会比较难懂，它的意思是，对于每个出现在 <code>$_GET</code>, <code>$_POST</code> 等位置的 key-value 对，都执行一遍 <code>unset($$key)</code>。<code>unset</code> 可以抹除某个变量，比如 <code>unset("v")</code> 会把一个名为 <code>v</code> 的变量给抹除。</p><p>然后下面有一个如果 <code>$_CONFIG['extraSecure']</code> 为真，则对 <code>$kw</code> 做过滤。它很烦，我们不想让它过滤。可以利用上面所说的 <code>unset</code>，让它把 <code>$_CONFIG</code> unset 掉，就可以 bypass 掉这个过滤了。</p><p>然后随便瞎注一下，发现 flag 不在 <code>messages</code> 里。联系到注释所说的，我们大概要拿到 admin 的密码，那样的话，我们就要拿到用户表。用户表的话，先盲猜一个表名是 <code>users</code>（如果猜不中的话，可以查 <code>information_schema</code> 来获得所有的表名）。</p><p>然后直接用 <code>UNION SELECT</code> 嗯注（前面加一个 <code>1=0</code> 让前面查不出结果，这样的话，第一条就是从 <code>UNION SELECT</code> 右边过来的）：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Not_easy_SQL_injection.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Not_easy_SQL_injection.png" loading="lazy"></a></p><p>发现运气不错（这里真的是运气不错），flag 直接就出现了。</p><blockquote><p>对于更一般的题目，由于 <code>UNION SELECT</code> 要求前后两个查询的列数必须相同，所以莽 <code>SELECT *</code> 大概率是会挂的，就需要再判断一下前面有多少列。<br>而且这里 <code>users</code> 的 <code>pass</code> 列恰好跟 <code>message</code> 的 <code>id</code> 列能对上，才可以直接通过 <code>id</code> 拿到 flag。否则就还需要枚举一下看看是哪列对应哪列。</p></blockquote><h2 id="reverse-shell-included">Reverse shell included</h2><p>这道题的 PHP 代码，核心的只有两行：</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span>=@(<span class="keyword">string</span>)<span class="variable">$_GET</span>[<span class="string">'str'</span>]; </span><br><span class="line"><span class="keyword">eval</span>(<span class="string">'$str="'</span>.<span class="title function_ invoke__">addslashes</span>(<span class="variable">$str</span>).<span class="string">'";'</span>); </span><br></pre></td></tr></tbody></table></figure><!-- katex: off --><p>这里毕竟有 <code>addslashes</code>，这就意味着我们不能用单、双引号了。不过我们还是可以用上面提到过的 <a href="https://www.php.net/manual/en/language.variables.variable.php">Variable variables</a>，比如说填 <code>${$str}</code> 之类的。</p><p>然后 <code>${ }</code> 里面还可以写函数，运行的时候就会调用函数求值。如果不确定的话，可以试试 <code>phpinfo()</code> 之类的函数确认一下：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_1.png" loading="lazy"></a></p><p>看起来确实可以。那……既然可以调用函数，那就直接上 <code>eval</code> 吧。不过这里有个问题，就是 <code>eval</code> 需要传入字符串，但是这里又不能用单、双引号，怎么办呢…</p><h3 id="solution-1">Solution 1</h3><p>PHP 的大部分版本支持 Unquoted strings，即如果你使用一个未被定义的常量（不以 <code>$</code> 开头），PHP 会把它当成字符串来用。</p><p>例如，如果运行 <code>var_dump(NONEXISTENT);</code>，PHP 就会输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Notice: Use of undefined constant NONEXISTENT - assumed 'NONEXISTENT' in %s on line %d</span><br><span class="line">string(11) "NONEXISTENT"</span><br></pre></td></tr></tbody></table></figure><p>Notice 那一行只是警告，不会真的输出到网页。不过从第二行的 <code>string(11) "NONEXISTENT"</code> 可以看出，PHP 确实把 <code>NONEXISTENT</code> 当成 <code>"NONEXISTENT"</code> 来用了。</p><blockquote><p>从 PHP 7.2.x 版本开始，就会报 Warning 而不是 Notice。并且从 8.x.x 开始，这个就会抛出错误（就是说不能用了）。</p></blockquote><p>不过这个有个限制，就是这个字符串只能是合法的常量名，像 <code>a=b</code> 就不行。</p><p>不过这个也好说，直接套一层 base64 编码。base64 编码之后的一般是合法的常量名（首字符一般是字母，后面一般都是字母和数字），如果编码出来的字符串末尾有 <code>=</code> 占位符的话，可以去掉，在这里不影响解码。</p><p>读取文件并输出，可以使用 <code>echo readfile("flag.php");</code>（注意末尾分号），base64 之后就是 <code>ZWNobyByZWFkZmlsZSgiZmxhZy5waHAiKTs=</code>。</p><p>于是我们就发送一个 <code>str</code> 是 <code>${eval(base64_decode(ZWNobyByZWFkZmlsZSgiZmxhZy5waHAiKTs))}</code> 的 payload，就行了。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_sol_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_sol_1.png" loading="lazy"></a></p><h3 id="solution-2">Solution 2</h3><p>另外一个思路就是，如果不能直接写字符串的话，我们可以引用另外的变量传给 <code>eval</code>。但是哪来的变量能用呢？</p><!-- katex: off --><p>一个很直接的想法就是用 <code>$_GET</code>，我们可以把 <code>$_GET[0]</code> 传给 <code>eval</code>，即令 <code>str</code> 为 <code>${eval($_GET[0])}</code>；然后再加一个名字是 <code>0</code> 的参数，这个参数的内容就可以随便写了，比如我们想读文件，就可以用 <code>echo readfile("flag.php");</code>。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_sol_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Reverse_shell_included_sol_2.png" loading="lazy"></a></p><h2 id="php-pop">PHP POP</h2><p>按照惯例，先访问一下，然后获得 PHP 源代码（下面的代码是稍微格式化过的）（<code>get_magic_quotes_gpc</code> 因为上面已经说过的原因，就忽略了）。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">"flag.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">just4fun</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$enter</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$secret</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$pass</span> = <span class="variable">$_GET</span>[<span class="string">'pass'</span>];</span><br><span class="line"><span class="variable">$o</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$pass</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$o</span>) {</span><br><span class="line">  <span class="variable">$o</span>-&gt;secret = <span class="variable">$flag</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">$o</span>-&gt;secret === <span class="variable">$o</span>-&gt;enter)</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Congratulation! Here is my secret: "</span>.<span class="variable">$o</span>-&gt;secret;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"Oh no... You can't fool me"</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">echo</span> <span class="string">"are you trolling?"</span>;</span><br></pre></td></tr></tbody></table></figure><p><del>说实话，这道题我做的时候是走了挺多弯路的。</del></p><p>首先看一下，感觉核心就是 <code>unserialize</code> 这个函数了。第一感觉就是能不能在 <code>unserialize</code> 里面执行代码，或者读取 <code>$flag</code> 这个变量来用。但是很遗憾的是，前者由于没有魔术方法，不太行；后者直接就没找到相关资料。</p><p>不过反过来想一想，如果可以用上面的方法，它就没有必要多此一举弄 <code>$enter</code> 和 <code>$secret</code> 了。一个可行的思路，可能是把 <code>$o-&gt;enter</code> 指向 <code>$o-&gt;secret</code>，这样的话就可以把这两个变量“绑定”在一起，也就可以绕过判断了。</p><p>然后翻了一下，发现好像 PHP 确实有 reference，可以用 <code>&amp;</code>，于是我们可以在本地写个脚本，让 <code>$o-&gt;enter</code> 指向 <code>$o-&gt;secret</code>，再调用 <code>serialize</code> 生成 payload。</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">just4fun</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$enter</span>;</span><br><span class="line">  <span class="keyword">var</span> <span class="variable">$secret</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="variable">$o</span> = <span class="keyword">new</span> just4fun;</span><br><span class="line"><span class="variable">$o</span>-&gt;enter = &amp;<span class="variable">$o</span>-&gt;secret;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$o</span>);</span><br></pre></td></tr></tbody></table></figure><p>就得到 payload <code>O:8:"just4fun":2:{s:5:"enter";N;s:6:"secret";R:2;}</code>。然后把这个 payload 扔上去，就能拿到 flag。</p><h1 id="week-4">Week 4</h1><h2 id="information">Information</h2><p>先用二进制编辑器打开图片，然后发现文件前面有一段文本，里面有一段非常“熟悉”的编码（其实就是 base64）。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Information_binary.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Information_binary.png" loading="lazy"></a></p><p>把它提取出来，解码一下，就拿到了 flag。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cGljb0NURnt0aGVfbTN0YWRhdGFfMXNfbW9kaWZpZWR9</span><br><span class="line">picoCTF{the_m3tadata_1s_modified}</span><br></pre></td></tr></tbody></table></figure><h2 id="matryoshka-doll">Matryoshka doll</h2><p>题目名字 “Matryoshka doll” 指的是俄罗斯套娃，提示这张图里面很可能藏着另一张图片。</p><p>所以来 <code>binwalk</code> 一下，果然发现了里面藏着一个 zip 压缩包。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ binwalk dolls.jpg</span><br><span class="line"></span><br><span class="line">DECIMAL       HEXADECIMAL     DESCRIPTION</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">0             0x0             PNG image, 594 x 1104, 8-bit/color RGBA, non-interlaced</span><br><span class="line">3226          0xC9A           TIFF image data, big-endian, offset of first image directory: 8</span><br><span class="line">272492        0x4286C         Zip archive data, at least v2.0 to extract, compressed size: 378942, uncompressed size: 383937, name: base_images/2_c.jpg</span><br><span class="line">651600        0x9F150         End of Zip archive, footer length: 22</span><br></pre></td></tr></tbody></table></figure><p>并且这个压缩包里面还有一个文件 2_c.jpg。于是我们用 <code>binwalk dolls.jpg -e</code> 把里面藏着的东西 <strong>E</strong>xtract 出来。</p><p>然后发现 2_c.jpg 似乎跟原图差不多。考虑到题目的名字指俄罗斯套娃，那…肯定还要继续拆。</p><p>用上面的方法，可以从 2_c.jpg 中拆出 3_c.jpg，然后继续从 3_c.jpg 拆出 4_c.jpg。然后从 4_c.jpg 继续拆，就发现得到的不是图片了，而是一个 flag.txt，这个文件里面的内容就是 flag。</p><h2 id="like1000">like1000</h2><p>下载附件 1000.tar，然后解压一下，得到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br><span class="line">├── 999.tar</span><br><span class="line">└── filler.txt</span><br></pre></td></tr></tbody></table></figure><p>这里面的 filler.txt 里面只有一些乱七八糟的内容。然后如果把 999.tar 继续解压，就会得到类似的内容（filler.txt 和 998.tar）。然后这样一直拆下去，拆到 1.tar 就应该能拿到 flag。</p><p>不过这样的话，手动解压 1000 次也太麻烦了，而且很慢。所以我们可以写一个脚本，帮忙解压：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    os.system(<span class="string">f'tar xf tar_temp/<span class="subst">{i}</span>.tar --directory tar_temp'</span>)</span><br><span class="line">    os.system(<span class="string">f'rm tar_temp/<span class="subst">{i}</span>.tar'</span>)</span><br></pre></td></tr></tbody></table></figure><p>把 1000.tar 放到 tar_temp 目录里面，然后跑一下这个脚本，它就会帮忙一层层地解压。解压到最后，tar_temp 里面的文件就剩下 filler.txt 和 flag.png。打开 flag.png，把 flag 抄下来即可。</p><h2 id="upper-lower-case">upper-lower case</h2><blockquote><p>题面按照真实事件改编。</p></blockquote><p>题面很简单，就是将 <code>y0u_re4lly_kn0w_th1s_congr4tulat10ns</code> 中的字母正确地大小写，使得其 MD5 等于 <code>7513209051f455fa44d0fa5cd0f3e051</code>。</p><p>数一下，这个字符串中有 25 个字母，所以一共有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>25</mn></msup><mo>≈</mo><mn>3</mn><mo>×</mo><mn>1</mn><msup><mn>0</mn><mn>7</mn></msup></mrow><annotation encoding="application/x-tex">2^{25} 3 10^7</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">5</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">7</span></span></span></span></span></span></span></span></span></span></span> 种可能。这个数量级，其实不是很大，可以考虑暴力全都试一遍。</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> itertools::Itertools;</span><br><span class="line"><span class="keyword">use</span> md5::{Digest, Md5};</span><br><span class="line"><span class="keyword">use</span> hex_literal::hex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">product</span> = (<span class="number">0</span>..<span class="number">25</span>).<span class="title function_ invoke__">map</span>(|_| [<span class="literal">false</span>, <span class="literal">true</span>].<span class="title function_ invoke__">into_iter</span>()).<span class="title function_ invoke__">multi_cartesian_product</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">combination</span> <span class="keyword">in</span> product {</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mask_iter</span> = combination.<span class="title function_ invoke__">into_iter</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">string</span>: <span class="type">Vec</span>&lt;_&gt; = <span class="string">"y0u_re4lly_kn0w_th1s_congr4tulat10ns"</span>.<span class="title function_ invoke__">bytes</span>()</span><br><span class="line">            .<span class="title function_ invoke__">map</span>(|ch| <span class="keyword">if</span> ch.<span class="title function_ invoke__">is_ascii_alphabetic</span>() &amp;&amp; mask_iter.<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>() {</span><br><span class="line">                ch.<span class="title function_ invoke__">to_ascii_uppercase</span>()</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                ch</span><br><span class="line">            })</span><br><span class="line">            .<span class="title function_ invoke__">collect</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> Md5::<span class="title function_ invoke__">digest</span>(&amp;string)[..] == hex!(<span class="string">"7513209051f455fa44d0fa5cd0f3e051"</span>) {</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"{}"</span>, std::str::<span class="title function_ invoke__">from_utf8</span>(&amp;string).<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后跑一遍这玩意，就能拿到 flag 了。</p><h2 id="whitepages">WhitePages</h2><p>首先先直接打开这个文件，然后经过观察，不难发现这个文件里面有两种字符：<code>U+2003</code> 和 <code></code>。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Whitepages_1.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Whitepages_1.png" loading="lazy"></a></p><p><code>U+2003</code> 查了一下，也是空格的一种。所以这个文件里面由两种空格组成。</p><p>遂考虑二进制。我们不妨把 <code>U+2003</code> 改成 <code>0</code>，把 <code></code>（空格）改成 <code>1</code>，然后用二进制解码一下，就得到了 flag。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Whitepages_2.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Whitepages_2.png" loading="lazy"></a></p><h2 id="sleuthkit-apprentice">Sleuthkit Apprentice</h2><p>下载下来是一个 disk.flag.img.gz 文件，首先当然是解压一下，拿到 disk.flag.img。</p><blockquote><p>如果不想那么麻烦的话，理论上用 Disk Genius 等硬盘管理软件打开，然后直接翻文件应该也是可以的。</p></blockquote><p>用 <code>fdisk</code> 看看里面有啥分区：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ fdisk disk.flag.img </span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.31.1).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m for help): p       </span><br><span class="line">Disk disk.flag.img: 300 MiB, 314572800 bytes, 614400 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x7389e82d</span><br><span class="line"></span><br><span class="line">Device         Boot  Start    End Sectors  Size Id Type</span><br><span class="line">disk.flag.img1 *      2048 206847  204800  100M 83 Linux</span><br><span class="line">disk.flag.img2      206848 360447  153600   75M 82 Linux swap / Solaris</span><br><span class="line">disk.flag.img3      360448 614399  253952  124M 83 Linux</span><br><span class="line"></span><br><span class="line">Command (m for help): q</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>实践表明，第一个分区里面没有，第二个是交换分区也不太可能，于是直接看第三个分区。</p><p>第三个分区的起始位置是 360448（单位是 sectors），然后换算成 byte 就是 184549376。然后就可以用 <code>mount</code> 挂载这个分区了：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo mount -o loop,offset=184549376 disk.flag.img /mnt</span><br></pre></td></tr></tbody></table></figure><p>挂载完之后，就可以在 <code>/mnt</code> 下面翻文件了。经过一通尝试之后，发现 flag 在 <code>/root/my_folder/flag.uni.txt</code> 里面，<code>cat</code> 一下即可。</p><h2 id="m00nwalk">m00nwalk</h2><p>听一下音频，有点像 SSTV 的信号。可以用 <a href="https://www.qsl.net/on6mu/rxsstv.htm">RX-SSTV</a> 接收并解析。</p><p>首先先安装一个 <a href="https://vac.muzychenko.net/en/download.htm">Virtual Audio Cable</a>（Lite 版本就行），用来把 wav 的音频输出重定向回输入，才能被 RX-SSTV 收到。</p><p>然后打开 RX-SSTV，再播放 message.wav，RX-SSTV 就会自动的设置好模式开始接收这张图片。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/m00nwalk_SSTV.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/m00nwalk_SSTV.png" loading="lazy"></a></p><p>接收完之后，就拿到了这张图片：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/m00nwalk_image.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/m00nwalk_image.png" loading="lazy"></a></p><p>把这张图片倒过来，把里面的 flag 抄下来就行了。</p><h2 id="weak-password">weak password</h2><h3 id="解压-zip-文件">解压 zip 文件</h3><p>zip 文件下载下来之后，发现它是有密码的。然后题面写着密码是 “five-byte printable characters”，即 5 位的可打印字符。这里用 John the Ripper 来破解密码。</p><p>首先先用 <code>zip2john</code> 把 zip 转成 John 能处理的 hash：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zip2john xxxtentacion.zip &gt; zip.hashes</span><br></pre></td></tr></tbody></table></figure><p>然后需要写一个密码字典生成器，让 John 针对性地破解。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> itertools.product(string.printable[:-<span class="number">5</span>], repeat=<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">''</span>.join(s))</span><br></pre></td></tr></tbody></table></figure><p>然后我们就可以用 John 破解了。</p><p>下面这句命令的意思是，让 <code>gen.py</code> 把字典打印到标准输出，然后重定向到 <code>john</code>。然后 <code>john</code> 用 <code>--pipe</code> 参数让它从标准输入读取密码字典。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ python3 gen.py | john zip.hashes --pipe</span><br><span class="line">Using default input encoding: UTF-8</span><br><span class="line">Loaded 1 password hash (PKZIP [32/64])</span><br><span class="line">Press Ctrl-C to abort, or send SIGUSR1 to john process for status</span><br><span class="line">61f@X            (xxxtentacion.zip/xxxtentacion/xxxtentacion.jpg)</span><br><span class="line">1g 0:00:04:21  0.003828g/s 1874Kp/s 1874Kc/s 1874KC/s 61f;q..61f@!</span><br><span class="line">Use the "--show" option to display all of the cracked passwords reliably</span><br><span class="line">Session completed</span><br></pre></td></tr></tbody></table></figure><p><del>看了下 CPU 占用，瓶颈居然在 Python 生成字典上。</del></p><p>然后就破解出 zip 的密码：<code>61f@X</code>。用这个密码解压 zip，就得到了一张 xxxtentacion.jpg 图片。</p><h3 id="解一层文件隐藏">解一层文件隐藏</h3><p><del>众所周知，jpg 是不能做 LSB 隐写的，因为 jpg 的有损压缩会破坏 LSB。</del></p><p>用二进制编辑器打开 xxxtentacion.jpg，然后发现这个文件的后面有一串非常熟悉的编码（其实还是 base64）。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_jpg_hidden.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_jpg_hidden.png" loading="lazy"></a></p><p>把这段内容复制出来，用 base64 解码一下：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_base64_decode.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_base64_decode.png" loading="lazy"></a></p><p>这里发现了一个 PNG 的文件头，把它保存下来，后缀名改成 <code>.png</code>，就可以得到一张图片：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_qrcode_raw.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_qrcode_raw.png" loading="lazy"></a></p><h3 id="二维码">二维码</h3><p>简单观察一下这张图，就发现它非常地“二维码”。根据二维码的格式，这张图应该先反色一下（根据右下角那个定位点），然后再把三个角修好，就得到了一个真正的二维码：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_qrcode.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_qrcode.png" loading="lazy"></a></p><p>扫描一下，得到 <code>6C75652C20666172206578636565647320796F75722062656C6965667D</code>。然后用 hex（16 进制）解码一下，得到 <code>lue, far exceeds your belief}</code>。</p><p><del>经过无厘头猜测，这个应该是 flag 的后半段，那前半段在哪呢？</del></p><h3 id="lsb">LSB</h3><p>我知道你很急，但你先别急。题目里面提到的 LSB 还没用上呢。</p><p>用 StegSolve.jar 打开原图，然后左右翻看。然后发现在 Red plane 0 里面（其实 Green 和 Blue 也有，而且是一样的），图片的左边有一串不明信息。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_red_plane_0.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_red_plane_0.png" loading="lazy"></a></p><p>然后用 Data Extract 功能，选中 Red 的 0，然后直接提取，就得到了 flag 的前半段：</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_data_extract.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Weak_Password_data_extract.png" loading="lazy"></a></p><p>把 flag 拼接一下，就有：<code>ctfshow{Your potential,value, far exceeds your belief}</code>。再按照题目的要求处理一下，就得到了最终的 flag：<code>ctfshow{Your_potential_value_far_exceeds_your_belief}</code>。</p><h2 id="简单的隐写">简单的隐写</h2><p>用上一题差不多的思路，用 StegSolve.jar 打开，发现 Red plane 1 的地方有一行不明信息。</p><p><a href="/images/2022-7-11-COMPASS-Summer-Writeup/Simple_Forensics.png" class="glightbox"><img src="/images/2022-7-11-COMPASS-Summer-Writeup/Simple_Forensics.png" loading="lazy"></a></p><p>但是并不能直接提取。<del>如果直接提取的话，虽然能看到 <code>ctfshow{</code>，但是后面的内容不完全对</del>。</p><p>原因是这幅图用了调色板（palette）。即每一个像素，只记录一个颜色的编号，再用编号去调色板中得到相应的 RGB 颜色。</p><p>然后隐写的信息是写在原始数据（即编号）里面的，而不是最终的 RGB 颜色，所以会出现一定的偏差。</p><p>不过好在 Python 的 Pillow 库可以直接读取这个原始数据。直接用这个脚本读一下就行：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">'mumuzi.png'</span>)</span><br><span class="line">pixels = <span class="built_in">list</span>(image.getdata())  <span class="comment"># 获取的是原始数据</span></span><br><span class="line">binary = [ pixel % <span class="number">2</span> <span class="keyword">for</span> pixel <span class="keyword">in</span> pixels[:<span class="number">400</span>] ]  <span class="comment"># 获取前 400 个像素的 LSB</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">''</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, binary)))  <span class="comment"># 打印</span></span><br></pre></td></tr></tbody></table></figure><p>然后得到：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01100011011101000110011001110011011010000110111101110111011110110011010001100110011001000</span><br><span class="line">01100010011010001100001011001100011000000101101001100110011001001100011011001010010110100</span><br><span class="line">11010000110101001101000011001100101101001110010011010000110010001100000010110100110011011</span><br><span class="line">00110011000110110000100110101001110000110010100110100011000100011000100110101001101100111</span><br><span class="line">11010000000000000000000000000000000000000000</span><br></pre></td></tr></tbody></table></figure><p>然后扔到 CyberChef 解码一下就能拿到 flag。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;del&gt;SUSTech CTF 课堂开课啦！孩子机器老被打，多半是寄了，用 COMPASS 牌 CTF 暑期训练课程，练攻击，直接给他打回去，妈妈一定要记住哦！&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;咳咳，总之这篇就是 SUSTech COMPASS 暑期 CTF 训练的题解（非官方）。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Hackergame 2021 Personal Write-up</title>
    <link href="https://blog.monadx.com/2021/10/31/Hackergame-2021/"/>
    <id>https://blog.monadx.com/2021/10/31/Hackergame-2021/</id>
    <published>2021-10-31T02:00:00.000Z</published>
    <updated>2023-07-02T06:16:15.945Z</updated>
    
    <content type="html"><![CDATA[<p>这是我个人的 write-up，仅包含我赛时会做的题（其它题看官方题解就好了，没必要再写一遍），记录自己做题时的奇奇怪怪的乱搞方法，仅供参考。</p><p>由于我只是个菜鸡，所以解题方法可能会有点绕，<del>可能原理甚至有问题</del>，请大佬原谅我这个菜鸡。</p><span id="more"></span><h1 id="前言">前言</h1><p>谨以此文纪念我参加的第一场 Hackergame。</p><figure><a href="/images/2021-10-30-Hackergame-2021/ranking.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/ranking.png" alt="" loading="lazy"></a><figcaption>Ranking</figcaption></figure><p>这次 Hackergame 感觉有比较多的乱搞题（然后才能让我这种乱搞选手能拿到可观的分数）。然后像是比较正经的 binary 题，我是差不多一个都不会做的（比赛结束前 1 天的时候，binary 还是 150）。</p><h1 id="目录">目录</h1><blockquote><p>没有链接样式的都是不会做的，或者是（对于有多个子问题的题目）没有完全做出来的。</p></blockquote><ul><li><a href="#签到">签到</a></li><li><a href="#进制十六参上">进制十六——参上</a></li><li><a href="#去吧追寻自由的电波">去吧！追寻自由的电波</a></li><li><a href="#猫咪问答-pro-max">猫咪问答 Pro Max</a></li><li><a href="#卖瓜">卖瓜</a></li><li><a href="#透明的文件">透明的文件</a></li><li><a href="#旅行照片">旅行照片</a></li><li><a href="#flag-助力大红包">FLAG 助力大红包</a></li><li>Amnesia<ul><li><a href="#amnesia---轻度失忆">轻度失忆</a></li><li>记忆清除</li></ul></li><li><a href="#图之上的信息">图之上的信息</a></li><li><a href="#easy-rsa">Easy RSA</a></li><li><a href="#加密的-u-盘">加密的 U 盘</a></li><li>赛博厨房<ul><li><a href="#level-0">Level 0</a></li><li><a href="#level-1">Level 1</a></li><li><a href="#level-2">Level 2</a></li><li>Level 3</li></ul></li><li>灯，等灯等灯<ul><li><a href="#level-0-1">Level 0</a></li><li>Level 1</li><li>Level 2</li></ul></li><li>只读文件系统</li><li>一石二鸟</li><li><a href="#micro-world">Micro World</a></li><li>卷王与野生的 GPA</li><li><a href="#阵列恢复大师">阵列恢复大师</a><ul><li><a href="#raid-0">1 - RAID 0</a></li><li><a href="#raid-5">2 - RAID 5</a></li></ul></li><li>链上预言家</li><li><a href="#助记词">助记词</a><ul><li><a href="#第一顿大餐">第一顿大餐</a></li><li><a href="#第二顿大餐">第二顿大餐</a></li></ul></li><li>Co-Program</li><li><a href="#马赛克">马赛克</a></li><li><a href="#minecraft">minecRaft</a></li><li><a href="#密码生成器">密码生成器</a></li><li>外星人的音游掌机</li><li><a href="#just-be-fun">JUST BE FUN</a></li><li>fzuu</li><li><a href="#pq">p😭q</a></li><li>Make a wish</li><li>超 OI 的 Writeup 模拟器</li></ul><h1 id="签到">签到</h1><p>点按钮可以切换 Page，然后不同的 Page 对应不同时间。<br>并且可以观察到，Page 的 number 就是 Unix 时间戳。<br><del>我们不妨大胆猜想</del>，把 Unix 时间戳设置成当前时间，即访问 <code>http://202.38.93.111:10000/?page=1634968833</code>，然后发现就可以获得 Flag。</p><h1 id="进制十六参上">进制十六——参上</h1><p>观察到右边的 flag 被遮住了，但是左边的 hex 却没有被遮住。所以就可以解析左边的 hex 得到右边的 flag：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">codecs.decode(</span><br><span class="line">    <span class="string">'666c61677b5930555f5348305531445f6b6e30775f4830575f74305f43306e763372745f4845585f746f5f546578547d'</span>,</span><br><span class="line">    <span class="string">'hex'</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="去吧追寻自由的电波">去吧！追寻自由的电波</h1><p>下载音频，发现音频播放速度非常快，大概是被暴力压缩了。<br>我们可以随便找点软件（我用了手边的 iMovie），把音频放慢，就可以听了。</p><p>题目云「使用了无线电中惯用的方法来区分字符串中读音相近的字母」，即 <code>e</code> 用 <code>echo</code> 表示，等。 虽然英语听力不太行，但是听首字母还是能勉强听得出来的。</p><blockquote><p>小彩蛋(?)：把音频放的没那么慢，可以听到女声；再放慢点，就变成了男声，这就说明……（逃）</p></blockquote><h1 id="猫咪问答-pro-max">猫咪问答 Pro Max</h1><blockquote><ol type="1"><li>2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？<br>提示：输入格式为 YYYYMMDD，如 20211023。请不要回答 “能” 或者 “不能”。</li></ol></blockquote><p>看到「已经无法访问」，直接下意识想到 <a href="https://web.archive.org">web.archive.org</a>。</p><p>在 web archive 里打开 <code>sec.ustc.edu.cn</code>，找到章程，然后就找到其通过日期为 2015 年 5 月 4 日。</p><blockquote><ol start="2" type="1"><li>中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？<br>提示：是一个非负整数。</li></ol></blockquote><p>查资料无果（可能我姿势不对），先下一题。</p><blockquote><ol start="3" type="1"><li>中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？<br>提示：正确答案的长度为 27，注意大小写。</li></ol></blockquote><p><del>经过多次搜索尝试</del>，在 Google 搜索 “LUG USTC” 并切换至“图片”一栏，就可以发现这么一张照片：</p><p><a href="/images/2021-10-30-Hackergame-2021/LUG_USTC_Lab.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/LUG_USTC_Lab.png" loading="lazy"></a></p><p>即 “Development Team of Library”，刚好是 27 个字。</p><blockquote><ol start="4" type="1"><li>在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？<br>提示：是一个非负整数。</li></ol></blockquote><p>搜索 “SIGBOVIK Newcomb-Benford”，然后就能找到一篇论文（集）：<a href="http://sigbovik.org/2021/proceedings.pdf">SIGBOVIK 2021</a>。</p><p>通过目录找到这篇文章，<del>然后仔细阅读，并且与作者友善探讨学术问题（大雾）。</del></p><p>实际上通过<del>简单</del>提取，不难发现附录的 figures 都是数据集，一共有 14 - 1 = 13 个</p><blockquote><ol start="5" type="1"><li>不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？<br>正确答案的长度为 9。</li></ol></blockquote><p>搜索 “IETF Protocol Police”，不难找到 <a href="https://datatracker.ietf.org/doc/html/rfc8962">RFC 8962</a>。</p><p>直接搜索关键词 <code>(e)mail</code> 或 <code>send</code>，不难找到「Send all your reports of possible violations and all tips about wrongdoing to <strong>/dev/null</strong>.」（不得不说，这个玩笑开得真是可以）。</p><p>所以答案就是 <code>/dev/null</code>，长度也刚好是 9。</p><p>（手动分割线）</p><p>然后至此我们找到了 1, 3, 4, 5 的答案，还剩下的第 2 题，可能的答案只有 6 种，手动枚举一下即可（<del>居然是 5 次，我还以为是 0</del>）。</p><h1 id="卖瓜">卖瓜</h1><p>说实话，我猜不出它（服务器 PHP 代码）是怎么算的，然后就搞不清楚具体是怎么溢出的，<del>但是还是可以瞎试</del>。</p><p><del>完了，我忘记我当时是怎么试的了。</del></p><p>Update：我想起来了。</p><p>首先，盲猜一下数值的范围是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup></mrow><annotation encoding="application/x-tex">2^{63}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span> 以内，然后整 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mfrac><msup><mn>2</mn><mn>63</mn></msup><mn>9</mn></mfrac><mo stretchy="false">⌋</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex"> + 1</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:1.36292em;vertical-align:-0.345em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01792em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">9</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913142857142857em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌋</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（<code>1024819115206086201</code>）个 9 斤的瓜，这样乘一下恰好能超过范围。</p><p>提交一下，得到「电子秤上已有 -9223372036854775808/20 斤的瓜」。</p><p>再加上 <code>1024819115206086200</code>（比上面少 1）个瓜，就变成了「电子秤上已有 -8/20 斤的瓜」。</p><p>接下来再买 <code>1</code> 个 9 斤瓜，再买 <code>1024819115206086201</code> 个，再买 <code>1024819115206086200</code> 个，此时，就有：「电子秤上已有 -7/20 斤的瓜」。</p><p>此时再买上 <code>3</code> 个 9 斤瓜，就可以刚好到 20 斤，就「恭喜你逃过一劫！」。</p><p><del>上面的操作不能合并，不要问我为什么，我也不知道。我只是瞎试的。</del></p><h1 id="透明的文件">透明的文件</h1><p>打开文件，发现里面的字符好像 <code>\033</code> 控制符（然后就是缺了 <code>\033</code>）。不妨试试在 <code>[</code> 前都加上 <code>\033</code>（据说 <code>\033</code> 后面一定会接着 <code>[</code>）。</p><p>然后打印之，可得：</p><p><a href="/images/2021-10-30-Hackergame-2021/transparent_console.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/transparent_console.png" loading="lazy"></a></p><p><del>不难读出</del>，flag 是 <code>flag{abxnniohkalmcowsayfiglet}</code>。</p><p>附读取程序：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buffer[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    FILE *f = <span class="built_in">fopen</span>(<span class="string">"transparent.txt"</span>, <span class="string">"rb"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fseek</span>(f, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">ftell</span>(f);</span><br><span class="line">    <span class="built_in">rewind</span>(f);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fread</span>(buffer, <span class="number">1</span>, size, f);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (buffer[i] == <span class="string">'['</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">'\033'</span>);</span><br><span class="line">        <span class="built_in">putchar</span>(buffer[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="旅行照片">旅行照片</h1><p>读题，发现题目的着重点在 KFC 上，并且其非常近海，猜想符合条件的 KFC 不多。<br>于是搜索 “海边 KFC”，虽然不能直接找到目标（大概?），但是过半的搜索结果都是关于“秦皇岛”的。<br>然后打开地图，定位到秦皇岛，查找附近的 KFC，得：</p><p><a href="/images/2021-10-30-Hackergame-2021/Qinhuangdao_KFC.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/Qinhuangdao_KFC.png" loading="lazy"></a></p><p>发现有一家 KFC 很接近海，打开卫星图模式，并放大观察：</p><p><a href="/images/2021-10-30-Hackergame-2021/Qinhuangdao_KFC_satellite.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/Qinhuangdao_KFC_satellite.png" loading="lazy"></a></p><p>可以发现停车位对上了，那块覆盖着植被的石头也对上了，<del>虽然 KFC 位置出现了一点偏差，但是不影响做题</del>。</p><p>观察原图的停车位方向和阴影方向，不难发现拍摄者面朝<strong>东南</strong>，时间是<strong>傍晚</strong>。</p><p>然后打开百度街景（不是广告），观察实地景象。<del>百度街景这都多久没更新了？</del></p><p><a href="/images/2021-10-30-Hackergame-2021/Qinhuangdao_dolphinarium.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/Qinhuangdao_dolphinarium.png" loading="lazy"></a></p><p><del>虽然没有 KFC</del>，但观察屋顶，还是能确定就是那里的。然后就能确定那三个大字就是「<strong>海豚馆</strong>」。</p><p>然后打开 <a href="https://www.kfc.com.cn/kfccda/storelist/index.aspx">KFC 门店信息查询</a>，定位秦皇岛。<br>虽然「新澳海底世界甜品餐厅」没有电话，猜测电话跟旁边的「新澳海底世界餐厅餐厅」一样（<strong>0335-7168800</strong>）。</p><p>最后还剩下楼层高度，看隔壁楼层数一下，大概是在 <strong>14</strong> 层左右（如果不对就上下多试几层就对了）。</p><h1 id="flag-助力大红包">FLAG 助力大红包</h1><p>总结题意：你需要用 256 个不同的 /8 IP 地址砍红包（访问对应 URL）。</p><p>但是这怎么可能呢，有些 IP 段本来就是有保留用途的，而且时间还限制 10 分钟。</p><p><del>经过一番胡思乱想</del>，发现可以通过携带 <code>X-Forwarded-For</code> header 来欺骗，就能轻松砍到 flag。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        r = requests.post(</span><br><span class="line">            <span class="string">'http://202.38.93.111:10888/invite/...'</span>,</span><br><span class="line">            data={ <span class="string">'ip'</span>: <span class="string">f'<span class="subst">{i}</span>.1.1.1'</span> },</span><br><span class="line">            headers={ <span class="string">'X-Forwarded-For'</span>: <span class="string">f'<span class="subst">{i}</span>.1.1.1'</span> })</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'助力成功！'</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f'Success <span class="subst">{i}</span>'</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">'操作速度太快了'</span> <span class="keyword">in</span> r.text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f'Too fast, sleep'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="amnesia---轻度失忆">Amnesia - 轻度失忆</h1><p><code>.data</code> 段没了，字符串常量是储存在这里的。既然不能用字符串常量，就分割成字符就可以了。</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'H'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'e'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'l'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'l'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'o'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">','</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">' '</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'w'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'o'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'r'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'l'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'d'</span>);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">'!'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="图之上的信息">图之上的信息</h1><p>经过简单尝试（瞎改原请求的参数，然后看错误信息），可以知道 GraphQL 里面有 <code>GUser</code> 类型，其中有 <code>id</code>, <code>username</code> 两个字段。</p><p>查 GraphQL 文档，找到“内省”部分，可以用如下代码获取 <code>GUser</code> 的所有字段：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ "query": "{ __type(name: \"GUser\") { name, fields { name }}}"}</span><br></pre></td></tr></tbody></table></figure><p>得到其所有字段：<code>id</code>, <code>username</code>, <code>privateEmail</code>。</p><p>再查询 <code>id</code> 为 1 的 admin 用户的 <code>privateEmail</code> 即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ "query": "{ user(id: 1) { id, username, privateEmail }}" }</span><br></pre></td></tr></tbody></table></figure><h1 id="easy-rsa">Easy RSA</h1><p>观察代码，我们有三个任务：</p><ol type="1"><li>计算 <code>p</code></li><li>通过 <code>value[-1]</code> 反推全部 <code>value</code></li><li>通过 <code>value_q</code> 反推 <code>q</code></li></ol><h2 id="计算-p">1. 计算 <code>p</code></h2><p>查找资料，可以找到一个叫“威尔逊定理”的东西，即当 <code>p</code> 为质数的时候，有：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>p</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>≡</mo><mn>1</mn><mspace width="0.5em"></mspace><mo stretchy="false">(</mo><mi mathvariant="normal">mod</mi><mo>⁡</mo><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(p - 2)! 1 ( p)</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.5em;"></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span></span></span></span></span></p><p>则：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo stretchy="false">!</mo><mo>≡</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo>×</mo><mfrac><mrow><mi>y</mi><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac><mo>≡</mo><mfrac><mn>1</mn><mrow><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mi>y</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>x</mi><mo>−</mo><mn>2</mn></mrow></munderover><mi>i</mi></mrow></mfrac><mo>≡</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mi>y</mi><mo>+</mo><mn>1</mn></mrow><mrow><mi>x</mi><mo>−</mo><mn>2</mn></mrow></munderover><mi>i</mi><mi>n</mi><mi>v</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mspace width="1em"></mspace><mo stretchy="false">(</mo><mi mathvariant="normal">mod</mi><mo>⁡</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">y! (x - 2)!   _{i = y + 1}^{x - 2} inv(i) ( x)</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.3074399999999997em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.601266em;vertical-align:-1.279826em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.1559920000000004em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.279826em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.2148900000000005em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000006em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∏</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:1em;"></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></span></p><p>代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">x, y</span>):</span><br><span class="line">    mul = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(y + <span class="number">1</span>, x - <span class="number">2</span> + <span class="number">1</span>):</span><br><span class="line">        mul = mul * <span class="built_in">pow</span>(i, x, x - <span class="number">2</span>) % x</span><br><span class="line">    <span class="keyword">return</span> mul</span><br></pre></td></tr></tbody></table></figure><h2 id="反推-value">2. 反推 <code>value</code></h2><p>这个部分涉及到一个最主要的函数就是 <code>sympy.nextprime</code>，先看看它的文档：</p><blockquote><p><code>def nextprime(n, ith = 1)</code><br>Return the ith prime greater than n.<br>See Also: prevprime: Return the largest prime smaller than n.</p></blockquote><p>……我感觉官方文档都告诉你应该怎么做了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_first_value</span>(<span class="params">last_value</span>):</span><br><span class="line">    val = last_value</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        val = sympy.prevprime(val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br></pre></td></tr></tbody></table></figure><h2 id="反推原始-q">3. 反推原始 <code>q</code></h2><p>这个部分就是给出这个式子（我们把这个原始的 <code>q</code> 称为 <code>x</code>）：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>≡</mo><msup><mi>x</mi><mi>e</mi></msup><mspace width="0.5em"></mspace><mo stretchy="false">(</mo><mi mathvariant="normal">mod</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">q x^e ( n)</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.65819em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.5em;"></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p>已知 <code>e</code>, <code>n</code>, <code>q</code>，求 <code>x</code>。</p><p><del>然而我不会求</del>，查资料，发现了这个：<a href="https://math.stackexchange.com/questions/2073284/finding-the-kth-root-modulo-m">Finding the k-th root modulo m</a>，简直完美。</p><p>按照这篇文章（回答）所说，首先求满足这一式子的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">u</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span></span></span></span>：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mtext> </mtext><mi>e</mi><mo>−</mo><mi>v</mi><mtext> </mtext><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">u , e - v , (n) = 1</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">u</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p><p>显然 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>gcd</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi>φ</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">(e, , (n)) = 1</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span style="margin-right:0.01389em;">g</span>cd</span><span class="mopen">(</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，这一步可以用 exgcd 做。</p><p>求出来了之后，就有</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>≡</mo><mo stretchy="false">(</mo><msup><mi>b</mi><mi>u</mi></msup><msup><mo stretchy="false">)</mo><mi>e</mi></msup><mspace width="0.5em"></mspace><mo stretchy="false">(</mo><mi mathvariant="normal">mod</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x (b</annotation></semantics></math><sup>u)</sup>e ( n)</span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.46375em;vertical-align:0em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">u</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">e</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.5em;"></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p>写成代码，就是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 n 我们通过 `first_value` 生成</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_original_q</span>(<span class="params">e, q, first_value</span>):</span><br><span class="line">    value = [ first_value ]</span><br><span class="line">    n = first_value</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        value.append(sympy.nextprime(value[i - <span class="number">1</span>]))</span><br><span class="line">        n *= value[-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这样求 phi 可以快不少，该函数要求 factors 中的 keys 都是质数。</span></span><br><span class="line">    factors = { v: <span class="number">1</span> <span class="keyword">for</span> v <span class="keyword">in</span> value }</span><br><span class="line">    pn = sympy.ntheory.factor_.totient._from_factors(factors)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Ex-GCD, 其中 h = gcd(e, pn)；u, v 含义如上所述。</span></span><br><span class="line">    (u, v, h) = sympy.polys.polytools.gcdex(e, pn)</span><br><span class="line"></span><br><span class="line">    x = <span class="built_in">pow</span>(q, <span class="built_in">int</span>(u) * e, n)</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></tbody></table></figure><p>经过验证，以上三个脚本算出的结果，代入进源程序中，都可以算出源码中对应的结果。</p><h2 id="rsa-解密">4. RSA 解密</h2><p>RSA 解密还需要一个数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span>（含义请自行翻看 RSA 文档，也可以看<a href="https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html">这篇</a>）。</p><p>这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi></mrow><annotation encoding="application/x-tex">d</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span> 需要满足以下式子：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>d</mi><mo>≡</mo><mn>1</mn><mspace width="0.5em"></mspace><mo stretchy="false">(</mo><mi mathvariant="normal">mod</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">ed 1 ( n)</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.5em;"></span><span class="mopen">(</span><span class="mop"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></span></p><p>在先进的 <code>Python 3.8+</code> 中，可以直接用 <code>pow(x, -1, mod)</code> 来算逆元，省事不少。</p><p>于是解密部分的代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pn = sympy.ntheory.factor_.totient._from_factors({ p: <span class="number">1</span>, q: <span class="number">1</span> })  <span class="comment"># phi(n)</span></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">pow</span>(e, -<span class="number">1</span>, pn)</span><br><span class="line"></span><br><span class="line">c = <span class="number">110644875422336073.</span>..</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, p * q)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="built_in">print</span>(m.to_bytes(<span class="number">32</span>, <span class="string">'big'</span>))</span><br></pre></td></tr></tbody></table></figure><p>然后就可以拿到 flag 了。</p><h1 id="加密的-u-盘">加密的 U 盘</h1><p>通过查询 LUKS 的使用文档，可以发现其可以使用密码或 keyfile 加密，于是大胆猜测改密码不会改变 keyfile 一类的东西（注：实际上是 master key 不会变）。</p><p>首先使用 <code>losetup -P /dev/loop1 day1.img</code> 将镜像挂载至 loopback（day2 同理）。</p><p>然后用 <code>cryptsetup luksDump --dump-master-key /dev/loop1p1</code> dump 出 master key。<code>MK dump</code> 里就是 master key。并用 <code>xxd</code> 或其它工具将 master key 写入文件。</p><p><a href="/images/2021-10-30-Hackergame-2021/Luks_masterkey_dump.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/Luks_masterkey_dump.png" loading="lazy"></a></p><p>接着用 master key 打开 <code>day2.img</code> 即可：<code>sudo cryptsetup luksOpen --master-key-file &lt;key file&gt; /dev/loop2p1 day2</code>。</p><p>最后把 <code>/dev/mapper/day2</code> mount 一下就能读出 <code>flag.txt</code> 了。</p><h1 id="赛博厨房">赛博厨房</h1><h2 id="level-0">Level 0</h2><p>写 4 个程序，针对不同菜谱执行不同程序即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">向右 x 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向下 1 步</span><br><span class="line">向左 x 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">向上 1 步</span><br><span class="line">向右 y 步</span><br><span class="line">拿起 1 个物品</span><br><span class="line">向下 1 步</span><br><span class="line">向左 y 步</span><br><span class="line">放下 1 个物品</span><br></pre></td></tr></tbody></table></figure><p>自行修改 <code>x</code>, <code>y</code> = <code>1</code> or <code>2</code> 来控制不同菜谱即可。</p><h2 id="level-1">Level 1</h2><p>写个简单循环，把物品不断放到锅中即可。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">向右 1 步</span><br><span class="line">拿起 100 个物品</span><br><span class="line">向下 1 步</span><br><span class="line">向左 1 步</span><br><span class="line">放下 1 个物品</span><br><span class="line">如果手上的物品大于等于 1 向上跳转 1 行</span><br></pre></td></tr></tbody></table></figure><h2 id="level-2">Level 2</h2><p>写 32 个程序，第 i 个程序分对应 <code>[0, 0, 0, 0, 0, i]</code> 这个菜谱。 然后再额外加一个程序，写 <code>向右 {} 步</code>，然后枚举数字，撞 hash（实际上是两个 sha256 和一个 arc4 随机?）。</p><p>暴力代码见：<a href="https://gist.github.com/YanWQ-monad/4febc8f8635514459a981adfefb1b9f1">GitHub Gist 4febc8f</a>。</p><h1 id="灯等灯等灯">灯，等灯等灯</h1><h2 id="level-0-1">Level 0</h2><p>解一个线性方程组即可。代码过丑就不放了（逃）。</p><p><del>我发现我不会写 % 256 意义下的高斯消元，于是我就直接用 Python 高精度，解完再取模。</del></p><p><del>然后我解完之后，没有去研究提交的 HTTP API，直接就写了个程序模拟鼠标点击（逃）</del></p><h1 id="micro-world">Micro World</h1><p><del>随便乱瞅一下（我不会告诉你我走了多少弯路的）</del>，能发现这个程序是用 pyinstaller 生成的。</p><p>然后就找一个 pyinstaller unpacker（我用的是 <a href="https://github.com/extremecoders-re/pyinstxtractor">extremecoders-re/pyinstxtractor</a>），然后就可以发现一个 <code>2.pyc</code> 文件。用 <code>pip</code> 安装 <code>pygame</code> 后，发现可以直接用 <code>python 2.pyc</code> 运行，能确定提取出了正确的东西。</p><p>接着继续尝试反编译，我这里找了 <a href="https://github.com/zrax/pycdc">zrax/pycdc</a>，能够逆向 Python 3.9 的字节码，但不完全能逆向出来（但是至少能看到大致的逻辑，也能看到点的数据）。</p><p><a href="/images/2021-10-30-Hackergame-2021/microworld_decompile.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/microworld_decompile.png" loading="lazy"></a></p><p>这是 <code>2.pyc</code> 中 <code>Point</code> 的定义：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, pos, vx, vy</span>):</span><br><span class="line">        (self.x, self.y) = pos</span><br><span class="line">        self.vx = vx</span><br><span class="line">        self.vy = vy</span><br></pre></td></tr></tbody></table></figure><p>不难猜出，<code>vx</code> 和 <code>vy</code> 就是这个点的移动速度（也就是 <code>list_</code> 每个元素的后两个值）。显然，只要把这个速度取相反数就可以还原出原 flag 图案了（显然碰撞是可逆的）。</p><p>然而我并不想对着 bytecode 翻译一遍代码，所以我决定动态“注入”到 <code>2.pyc</code> 里面改变量。下面我们先把 <code>2.pyc</code> 重命名成 <code>w2.pyc</code>，因为不能直接 <code>import 2</code>。</p><p>但是 <code>import w2</code> 后，<code>import</code> 没返回，窗口已经运行了，有点难改变量。<del>下面开始乱搞！</del></p><p>我们可以新建一个 <code>pygamx.py</code> 来 mock <code>pygame</code>，然后修改 <code>2.pyc</code> 的 bytecode：暴力把 <code>pygame</code> 改成 <code>pygamx</code>（暴力替换二进制数据即可）。</p><p><code>pygamx.py</code>：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pygame</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Clock</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">self</span>):</span><br><span class="line">            self.first = <span class="literal">True</span></span><br><span class="line">            self.clock = pygame.time.Clock()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">tick</span>(<span class="params">self, fps</span>):</span><br><span class="line">            <span class="comment"># 手动控制每一帧</span></span><br><span class="line">            <span class="built_in">input</span>()</span><br><span class="line">            <span class="comment"># self.clock.tick(fps)</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.first:</span><br><span class="line">                self.first = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="comment"># 经过测试，可以在这里反向 import 并访问 Pointlist 而不抛出 AttributeError</span></span><br><span class="line">                <span class="keyword">import</span> w2</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(w2.Pointlist)):</span><br><span class="line">                    p = w2.Pointlist[i]</span><br><span class="line">                    w2.Pointlist[i] = w2.Point((p.x, p.y), -p.vx, -p.vy)</span><br><span class="line"></span><br><span class="line">time = Time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># mock 其它 attribute</span></span><br><span class="line">init = pygame.init</span><br><span class="line">quit = pygame.quit</span><br><span class="line">mixer = pygame.mixer</span><br><span class="line">display = pygame.display</span><br><span class="line">event = pygame.event</span><br><span class="line">draw = pygame.draw</span><br><span class="line">QUIT = pygame.QUIT</span><br></pre></td></tr></tbody></table></figure><p>然后经过测试，可以在上面 <code>pygame.time.Clock.tick</code> 里面反向 <code>import w2</code>，修改 <code>list_</code> 和 <code>Pointlist</code>，把速度取反，就可以了。</p><p>此时直接运行 <code>python w2.pyc</code>，并且在控制台窗口用回车控制每一帧，看到 flag 差不多展示出来了就行了：</p><p><a href="/images/2021-10-30-Hackergame-2021/microworld_flag.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/microworld_flag.png" loading="lazy"></a></p><h1 id="阵列恢复大师">阵列恢复大师</h1><p><del>数据恢复软件都是浮云，手撕才是正道。</del></p><p>当时做题的时候，看着 RAID 5 通过的人比 RAID 0 多，所以就先跑去做 RAID 5 了。后来仔细思索一下，可能是因为 RAID 5 有软件能一键恢复吧。</p><h2 id="raid-0">1 - RAID 0</h2><p>额，在恢复之前，先来看一下 RAID 0 的结构。</p><p><a href="/images/2021-10-30-Hackergame-2021/RAID_0.svg" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/RAID_0.svg" loading="lazy"></a></p><p>说白了大概就是按块大小分块，然后按顺序依次存放在各个盘中。所以一个推论就是，一段内容只会出现在一个盘里面。</p><p>为了方便起见，先把硬盘名字按照字母序重命名成 1~8.img。</p><p>先随便看看这些盘的内容，然后不难发现，8.img 的 0x00000200 处有一个 <code>EFI PART</code>，这是 GPT 分区表的标志。于是就不难推测出 8.img 是第一个盘。</p><p><a href="/images/2021-10-30-Hackergame-2021/raid0_disk_8_head.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/raid0_disk_8_head.png" loading="lazy"></a></p><p>然后的话，再随便翻翻这些盘的内容，发现似乎空的部分（<code>0x00</code>）比较多。要确定盘的顺序的话，因为块与块之间是直接拼起来的，所以可以直接看内容的连续性来判断块的顺序，进而判断盘的顺序。</p><p>这样的话，随便翻看几下，发现 <code>0x008C0000</code> 和 <code>0x008E0000</code> 附近的内容有断层，而且丰富性比较高，有文本、乱码、零。并且从这两个“断层”的距离不难推测出块的大小是 128KB。（注意下面第 4 块盘的 <code>0x008E0000</code> 前的部分，<code>n</code> 后面应该有一个空格。）</p><table><thead><tr class="header"><th style="text-align: center;">Disk</th><th style="text-align: center;"><code>0x008C0000</code> 前</th><th style="text-align: center;"><code>0x008C0000</code> 后</th><th style="text-align: center;"><code>0x008E0000</code> 前</th><th style="text-align: center;"><code>0x008E0000</code> 后</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>2J..`...HD.....k</code></td><td style="text-align: center;"><code>Subtype /Link /R</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>ect [118.3625 23</code></td><td style="text-align: center;"><code>g_system_respons</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>iveness_under_lo</code></td><td style="text-align: center;"><code>...:......b.&lt;.dL</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>.q,.[.Q..B....Y.</code></td><td style="text-align: center;"><code>0470796 00000 n</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;"><code>0 obj.&lt;&lt; /A 489</code></td><td style="text-align: center;"><code>..g..b.c.D\...G.</code></td><td style="text-align: center;"><code>F.O...\i...o.G..</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>000 n .000007636</code></td><td style="text-align: center;"><code>M.t.p...V+.,=.2.</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>.0000470505 0000</code></td><td style="text-align: center;"><code>4....%......,.iI</code></td><td style="text-align: center;">0x00000000</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">0x00000000</td><td style="text-align: center;"><code>0 R /Border [ 0</code></td><td style="text-align: center;"><code>n .0000076610 00</code></td><td style="text-align: center;"><code>.0..TL$w.......1</code></td></tr></tbody></table><p>根据 RAID 0 的结构，不难推测出 <code>1 - 2</code>，<code>2 - 3</code>，<code>4 - 7</code>，<code>5 - 8</code>，<code>8 - 6</code>（能分成三大块：<code>5 8 6</code>，<code>1 2 3</code>，<code>4 7</code>）。（如果觉得看表难推测的话，可以再看看这些位置的上下文，找一下文本的规律（常见词等）。）</p><p>到这里，可能的盘的顺序就只剩下 <code>8 6 1 2 3 4 7 5</code> 和 <code>8 6 4 7 1 2 3 5</code> 两种，已经很优了。如果懒的话，可以直接两种方法都试一下，看看哪种对的就行了。</p><p>实际上，在 <code>0x001C0000</code> ~ <code>0x001E0000</code> 的地方，可以观测到内容从有（非 0x00）变无（0x00）：</p><table><thead><tr class="header"><th style="text-align: center;">Disk</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th><th style="text-align: center;">4</th><th style="text-align: center;">5</th><th style="text-align: center;">6</th><th style="text-align: center;">7</th><th style="text-align: center;">8</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Not 0x00?</td><td style="text-align: center;">T</td><td style="text-align: center;">partial</td><td style="text-align: center;">F</td><td style="text-align: center;">F</td><td style="text-align: center;">F</td><td style="text-align: center;">T</td><td style="text-align: center;">F</td><td style="text-align: center;">T</td></tr></tbody></table><p>据此，能推断出第 2 块盘在第 4 个位置。也就是说上面的两个方案，<code>8 6 1 2 3 4 7 5</code> 是对的。</p><p>既然顺序和块大小（128 KB）都有了，直接恢复出完整镜像（我用了一下 DiskGenius），然后把镜像挂载一下就行了。</p><h2 id="raid-5">2 - RAID 5</h2><p>同理，先来看看 RAID 5 的结构。</p><p><a href="/images/2021-10-30-Hackergame-2021/RAID_5.svg" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/RAID_5.svg" loading="lazy"></a></p><p>与上面 RAID 0 不同的是，它多了一块奇偶校验块。</p><p>也像上面一样，先瞅瞅这些盘的头部。</p><p><a href="/images/2021-10-30-Hackergame-2021/raid5_disk_23_head.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/raid5_disk_23_head.png" loading="lazy"></a></p><p>然后可以发现 2.img 和 3.img 有 GPT 头，故可以确定这两个盘一个是第一个位置，另一个是最后一个位置（首个校验块所在盘）。而且在 2.img 的 <code>0x0040400</code> 的地方可以找到 ext2/3/4 的 superblock。</p><p>所以现在就只剩下 12 种方案了……这一次我比较懒，就没有继续了（而且也懒得分析比较复杂的 RAID 5 了）。</p><p>然后我真的就去莽了，块大小 64 KB 和 256 KB 都莽一下（不要问我为什么不试 128 KB），再把上面 12 种方案都过一遍。实际操作就是在 DiskGenius 上排顺序，看看那个拼好了之后，DiskGenuis 能找到 ext2/3/4 分区。</p><p>最后试了几下，试出来了 <code>2 4 1 5 3</code>（块大小忘了实际上是多少了），然后用 DiskGenius 导出镜像（不知道为啥我那玩意不支持导出大于 1 MB 的文件），然后瞎搞一下，mount 上了就行了。</p><p><del>为什么我导出镜像之后还要用 testdisk 找一下分区后，导出分区才能挂载。</del></p><h1 id="助记词">助记词</h1><p>说句实话，这道题一点也不 math。</p><h2 id="第一顿大餐">第一顿大餐</h2><p>下载程序源码，打开。</p><p>其中 <code>cn.edu.ustc.lug.hack.mnemonic_phrase.Instance</code> 里的 <code>post</code> 是主要逻辑（flag 的处理也在这里），并且<del>不难发现</del>，这个函数里面有一个 for 循环，调试一下，发现每次请求好像只会循环一次。</p><p>回头看 HTTP API，发现似乎可以一次性提交一个数组，尝试一下提交 32 个相同的助记词，然后发现正好可以拿到第一个 flag。</p><h2 id="第二顿大餐">第二顿大餐</h2><p><del>作为一个逆向过 Minecraft 种子生成的人，怎么会止步于此呢</del></p><p>观察发现，<code>sleep</code> 函数是在 <code>Phrase.equals</code> 方法中执行的，然后我们并没有在本项目中发现直接调用它的地方。</p><p>再思考一下，能发现它会在 <code>Set&lt;Phrase&gt;</code>（实际上是 <code>LinkedHashSet</code>）中被 <code>Set</code> 调用。</p><p>第二个 flag 需要卡顿 9 秒，掐指一算，大概需要调用 <code>equals</code> 450 次，大概是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 的级别。</p><p><del>查看 <code>LinkedHashSet</code> 源代码</del>，猜测一下，我们要构造 <code>hash</code> 相同的 <code>Phrase</code>，让 <code>Set</code> 进行 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 级别次数的比较。</p><p>然后看 <code>Phrase.hash</code> 方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> Objects.hash(<span class="built_in">this</span>.text, <span class="built_in">this</span>.time, <span class="built_in">this</span>.user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再看 <a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/Objects.java#l127"><code>Object.hash</code> 方法</a>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object... values)</span> {</span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再看 <a href="http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/be44bff34df4/src/share/classes/java/util/Arrays.java#l4139"><code>Arrays.hashCode</code> 方法</a>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">(Object a[])</span> {</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 在这个例子中与这个无关</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object element : a)</span><br><span class="line">        result = <span class="number">31</span> * result + (element == <span class="literal">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>换句话说，就是分别对 <code>this.text</code>, <code>this.time</code>, <code>this.user</code> 分别调用 <code>.hashCode()</code>，然后再拼在一起。这里先看 <code>this.text</code>（即 <code>String</code>）的 <code>hashCode</code>。</p><p><a href="http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/String.java#l1452"><code>String.hashCode</code></a>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; value.length; i++)</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        hash = h;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这个函数就是首先做了一个缓存，如果 <code>hash</code>（<code>String</code> 的一个 field）存在，就不算了。主要逻辑在 for 循环上。</p><p>我们可以把这个算法提取出来，暴力算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">600^4</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 种 hash（其实也可以双向 BFS，我这里没用）。</p><p>下面的暴力代码用 Rust 写，并且进行了一点小优化（因为算 <code>hashCode</code> 的过程是线性的），大概 5 分钟能跑完全部 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn><msup><mn>0</mn><mn>4</mn></msup></mrow><annotation encoding="application/x-tex">600^4</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span> 种 hash：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"><span class="keyword">use</span> std::num::Wrapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MNEMONICS_TEXTS: [&amp;<span class="type">str</span>; <span class="number">600</span>] = [ ... ];</span><br><span class="line"><span class="keyword">const</span> POW_31: [<span class="type">u32</span>; <span class="number">15</span>] = [ <span class="number">1</span>, <span class="number">31</span>, <span class="number">961</span>, <span class="number">29791</span>, <span class="number">923521</span>, <span class="number">28629151</span>, <span class="number">887503681</span>, <span class="number">1742810335</span>, <span class="number">2487512833</span>, <span class="number">4098453791</span>, <span class="number">2498015937</span>, <span class="number">129082719</span>, <span class="number">4001564289</span>, <span class="number">3789408671</span>, <span class="number">1507551809</span> ];</span><br><span class="line"><span class="comment">// POW_31[i] 记录的是 pow(31, i) 的结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Mnemonics</span> {</span><br><span class="line">    pow: <span class="type">u32</span>,</span><br><span class="line">    hash: <span class="type">u32</span>,</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">hash_str</span>(s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() {</span><br><span class="line">        x = x * <span class="title function_ invoke__">Wrapping</span>(<span class="number">31</span>) + <span class="title function_ invoke__">Wrapping</span>(c <span class="keyword">as</span> <span class="type">u32</span>);</span><br><span class="line">    }</span><br><span class="line">    x.<span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Mnemonics</span> {</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(_index: <span class="type">usize</span>, text: &amp;<span class="symbol">'static</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> Mnemonics {</span><br><span class="line">        Mnemonics {</span><br><span class="line">            pow: POW_31[ text.<span class="title function_ invoke__">len</span>() ],</span><br><span class="line">            hash: <span class="title function_ invoke__">hash_str</span>(text),</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">join_hash</span>(ss: &amp;[&amp;Mnemonics]) <span class="punctuation">-&gt;</span> <span class="type">u32</span> {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="title function_ invoke__">Wrapping</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">first</span> = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">s</span> <span class="keyword">in</span> ss {</span><br><span class="line">        <span class="keyword">if</span> !first {</span><br><span class="line">            x = x * <span class="title function_ invoke__">Wrapping</span>(<span class="number">31</span>) + <span class="title function_ invoke__">Wrapping</span>(<span class="string">' '</span> <span class="keyword">as</span> <span class="type">u32</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        x = x * <span class="title function_ invoke__">Wrapping</span>(s.pow) + <span class="title function_ invoke__">Wrapping</span>(s.hash);</span><br><span class="line"></span><br><span class="line">        first = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    x.<span class="number">0</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mnemonics</span> = Vec::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, text) <span class="keyword">in</span> MNEMONICS_TEXTS.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">        mnemonics.<span class="title function_ invoke__">push</span>(Mnemonics::<span class="title function_ invoke__">new</span>(i, text));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只收集 hashCode 为 [0, 20) 的</span></span><br><span class="line">    <span class="comment">// 这样取是没问题的，假设 hash 足够均匀的话</span></span><br><span class="line">    <span class="keyword">const</span> HASH_RANGE: <span class="type">u32</span> = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span> = HashMap::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">hash</span> <span class="keyword">in</span> <span class="number">0</span>..HASH_RANGE {</span><br><span class="line">        result.<span class="title function_ invoke__">insert</span>(hash, Vec::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">for</span> (i1, m1) <span class="keyword">in</span> mnemonics.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">        <span class="title function_ invoke__">for</span> (i2, m2) <span class="keyword">in</span> mnemonics.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">            <span class="title function_ invoke__">for</span> (i3, m3) <span class="keyword">in</span> mnemonics.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">                <span class="title function_ invoke__">for</span> (i4, m4) <span class="keyword">in</span> mnemonics.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() {</span><br><span class="line">                    <span class="comment">// 这个 \times 31 下面会提到</span></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">hash</span> = <span class="title function_ invoke__">join_hash</span>(&amp;[&amp;m1, &amp;m2, &amp;m3, &amp;m4]).<span class="title function_ invoke__">wrapping_mul</span>(<span class="number">31</span>);</span><br><span class="line">                    <span class="keyword">if</span> hash &gt;= HASH_RANGE {</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">let</span> <span class="variable">plan</span> = [i1, i2, i3, i4];</span><br><span class="line">                    result.<span class="title function_ invoke__">get_mut</span>(&amp;hash).<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">push</span>(plan);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"{:?}"</span>, result);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的程序只会输出 <code>hashCode</code> 对应的单词的序号。</p><p>再写个程序解析这个输出（把两个程序分开，进行下面的操作的时候就不用重复破解 hash）：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s = [ ... ]  <span class="comment"># 单词表</span></span><br><span class="line">p = { ... }  <span class="comment"># 上面的输出</span></span><br><span class="line">d = [ ... ]  <span class="comment"># delay，见下面的文字</span></span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">32</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> p[<span class="number">20</span> - d[i]]:</span><br><span class="line">        results.append(<span class="string">'"{}"'</span>.<span class="built_in">format</span>( <span class="string">' '</span>.join([ s[i] <span class="keyword">for</span> i <span class="keyword">in</span> x ] )))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= <span class="number">32</span> <span class="keyword">or</span> d[i - <span class="number">1</span>] != d[i]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">t = <span class="string">', '</span>.join(results)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f'[<span class="subst">{t}</span>]'</span>)</span><br></pre></td></tr></tbody></table></figure><p>但是直接把暴力出的结果扔进程序里，发现最多只能卡 3 秒左右，是怎么回事？</p><p>我们继续看回去那个加单词的循环，把每一次循环所需的时间输出，就可以发现它的时间是 <code>24 - 49 - 71 - 103 - ... - 254 - 0 - 24 - 47 - ... - 243 - 0 - 23 - ...</code>（数字不是复制的，但是趋势是一样的）。</p><p><code>Phrase.hash</code> 是 <code>Objects.hash(this.text, this.time, this.user);</code>，每过一秒，<code>this.time</code> 的变化就会使我们精心构造的 hash 冲突给毁掉。</p><p>这个有点难处理，观察回 <code>Arrays.hashCode</code>，我们可以把 <code>this.text.hashCode * 31</code> 后的 hash 缓存起来，每次当 <code>this.time</code> 加一的时候，我们就让 <code>this.text.hashCode * 31</code> 减一。</p><p>至于在这个长度为 32 的序列中，应该什么时候减一的这个问题，我也没有好的思路，只是随便试，试了一个相对较好的：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = [ <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">9</span> ]</span><br></pre></td></tr></tbody></table></figure><p>由于实际运行时的微妙时间差（即开始运行的时候，并不是完全正对着每秒的开头的），所以要在在线的网站上多试几次。</p><h1 id="马赛克">马赛克</h1><p>这道题的简单题意就是，给你一个打了码的二维码，并且给出打码的程序（算法是模糊部分的一个大的 block 的颜色，是这个区域内颜色的平均值）。<del>简单算一下信息量，感觉还是能复原的。</del></p><p>一些用词（为了避免混乱所以先说明）：二维码的块：指模糊前的二维码的一个黑白块；码的块：指打码部分的一个色块（应该没毛病吧）。</p><p>于是乎，最朴素的方法就是……枚举原二维码每个块的黑白，然后看看跟模糊后的是否一致，但是这样做时间成本太大了。</p><p>然后可以发现，这个码的一个块的影响范围是有限的，大概就 10 个左右的二维码块。于是我们就可以针对每个码的块，枚举其下的二维码的黑白。再把每一个块的有效方案拼起来即可。</p><p><del>原理听懂了吗？原理大概就这个样子。但是……你发现这个确实并不好实现（大概?）</del></p><p>具体实现的话，假设前面处理了若干个块，这些块拼在一起的有效方案（可能有多个）放在一个数组 <code>p</code> 里。然后处理一个新的块的时候，就把当前区域的方案，与 <code>p</code> 中的匹配（能相容的就结合），把新的方案放到一个新的数组 <code>q</code> 供下一轮使用。</p><p>具体代码（调试输出十分炫酷，建议运行）：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">X, Y = <span class="number">103</span>, <span class="number">137</span>     <span class="comment"># 马赛克左上角位置(单位为像素)</span></span><br><span class="line">N = <span class="number">20</span>              <span class="comment"># 马赛克块的数量（共N*N块）</span></span><br><span class="line">BOX_SIZE = <span class="number">23</span>       <span class="comment"># 每个马赛克块的大小（边长，单位为像素）</span></span><br><span class="line">PIXEL_SIZE = <span class="number">11</span>     <span class="comment"># 二维码每个块的大小（边长，单位为像素）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc_block_color</span>(<span class="params">img, x, y</span>):</span><br><span class="line">    x1 = X + x * BOX_SIZE</span><br><span class="line">    x2 = X + (x + <span class="number">1</span>) * BOX_SIZE</span><br><span class="line">    y1 = Y + y * BOX_SIZE</span><br><span class="line">    y2 = Y + (y + <span class="number">1</span>) * BOX_SIZE</span><br><span class="line">    <span class="keyword">return</span> math.floor(img[x1:x2, y1:y2].mean())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_qr_block_in</span>(<span class="params">mx, my, qx, qy</span>):</span><br><span class="line">    <span class="comment"># 检查 (qx, qy) 这个二维码块 是否影响 (mx, my) 这个打码块</span></span><br><span class="line">    X1 = X + mx * BOX_SIZE</span><br><span class="line">    X2 = X + (mx + <span class="number">1</span>) * BOX_SIZE - <span class="number">1</span></span><br><span class="line">    Y1 = Y + my * BOX_SIZE</span><br><span class="line">    Y2 = Y + (my + <span class="number">1</span>) * BOX_SIZE - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    x1 = qx * PIXEL_SIZE</span><br><span class="line">    x2 = (qx + <span class="number">1</span>) * PIXEL_SIZE - <span class="number">1</span></span><br><span class="line">    y1 = qy * PIXEL_SIZE</span><br><span class="line">    y2 = (qy + <span class="number">1</span>) * PIXEL_SIZE - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (X1 &lt;= x1 &lt;= X2 <span class="keyword">and</span> Y1 &lt;= y1 &lt;= Y2) <span class="keyword">or</span> (X1 &lt;= x1 &lt;= X2 <span class="keyword">and</span> Y1 &lt;= y2 &lt;= Y2) \</span><br><span class="line">    <span class="keyword">or</span> (X1 &lt;= x2 &lt;= X2 <span class="keyword">and</span> Y1 &lt;= y1 &lt;= Y2) <span class="keyword">or</span> (X1 &lt;= x2 &lt;= X2 <span class="keyword">and</span> Y1 &lt;= y2 &lt;= Y2):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paint_with</span>(<span class="params">img, x, y, color</span>):</span><br><span class="line">    <span class="comment"># 将 (x, y) 二维码块涂成 color 色</span></span><br><span class="line">    x1 = x * PIXEL_SIZE</span><br><span class="line">    x2 = (x + <span class="number">1</span>) * PIXEL_SIZE</span><br><span class="line">    y1 = y * PIXEL_SIZE</span><br><span class="line">    y2 = (y + <span class="number">1</span>) * PIXEL_SIZE</span><br><span class="line">    img[x1:x2, y1:y2] = color</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plan</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, plan = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> plan <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            plan = {}</span><br><span class="line">        self.plan = plan</span><br><span class="line">        self.min_x = <span class="number">10000</span></span><br><span class="line">        self.min_y = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">compatible</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 检查此 plan 是否与 `other` 兼容</span></span><br><span class="line">        <span class="keyword">for</span> (x, y), value <span class="keyword">in</span> self.plan.items():</span><br><span class="line">            <span class="keyword">if</span> (data := other.plan.get((x, y))) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">and</span> data != value:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x, y, data</span>):</span><br><span class="line">        self.min_x = <span class="built_in">min</span>(self.min_x, x)</span><br><span class="line">        self.min_y = <span class="built_in">min</span>(self.min_y, y)</span><br><span class="line">        self.plan[(x, y)] = data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 将此 plan 与 `other` 结合，返回新的 plan</span></span><br><span class="line">        <span class="keyword">assert</span> self.compatible(other)</span><br><span class="line">        new = Plan(self.plan.copy())</span><br><span class="line">        <span class="keyword">for</span> (x, y), value <span class="keyword">in</span> other.plan.items():</span><br><span class="line">            new.push(x, y, value)</span><br><span class="line">        <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_initial_plan</span>(<span class="params">img</span>):</span><br><span class="line">    <span class="comment"># 这是获取初始的 plan，主要包含码周边的一圈二维码块</span></span><br><span class="line"></span><br><span class="line">    X1 = X + <span class="number">0</span> * BOX_SIZE</span><br><span class="line">    X2 = X + N * BOX_SIZE</span><br><span class="line">    Y1 = Y + <span class="number">0</span> * BOX_SIZE</span><br><span class="line">    Y2 = Y + N * BOX_SIZE</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_in</span>(<span class="params">x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> X1 &lt;= x &lt;= X2 <span class="keyword">and</span> Y1 &lt;= y &lt;= Y2</span><br><span class="line"></span><br><span class="line">    plan = Plan()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> np.ndindex(<span class="number">57</span>, <span class="number">57</span>):</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> np.ndindex(N, N):</span><br><span class="line">            <span class="keyword">if</span> check_qr_block_in(i, j, x, y):</span><br><span class="line">                x1 = x * PIXEL_SIZE</span><br><span class="line">                x2 = (x + <span class="number">1</span>) * PIXEL_SIZE - <span class="number">1</span></span><br><span class="line">                y1 = y * PIXEL_SIZE</span><br><span class="line">                y2 = (y + <span class="number">1</span>) * PIXEL_SIZE - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> is_in(x1, y1):</span><br><span class="line">                    color = img.getpixel((y1, x1))</span><br><span class="line">                    plan.push(x, y, color)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="keyword">not</span> is_in(x2, y2):</span><br><span class="line">                    color = img.getpixel((y2, x2))</span><br><span class="line">                    plan.push(x, y, color)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    POSITION_BLOCK = [(<span class="number">50</span>, <span class="number">50</span>), (<span class="number">50</span>, <span class="number">28</span>), (<span class="number">28</span>, <span class="number">50</span>), (<span class="number">28</span>, <span class="number">28</span>)]  <span class="comment"># 定位块</span></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> POSITION_BLOCK:</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> np.ndindex(<span class="number">5</span>, <span class="number">5</span>):</span><br><span class="line">            d = <span class="built_in">max</span>(<span class="built_in">abs</span>(x - <span class="number">2</span>), <span class="built_in">abs</span>(y - <span class="number">2</span>))</span><br><span class="line">            color = <span class="number">0</span> <span class="keyword">if</span> (d % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">else</span> <span class="number">255</span></span><br><span class="line">            plan.push(block[<span class="number">0</span>] + x - <span class="number">2</span>, block[<span class="number">1</span>] + y - <span class="number">2</span>, color)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plan</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">iter_blocks</span>():</span><br><span class="line">    <span class="comment"># 枚举顺序从四周到中心，方便先利用已知数据</span></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> np.ndindex(N, N):</span><br><span class="line">            dx = <span class="built_in">min</span>(i, (N - <span class="number">1</span>) - i)</span><br><span class="line">            dy = <span class="built_in">min</span>(j, (N - <span class="number">1</span>) - j)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">min</span>(dx, dy) == d:</span><br><span class="line">                <span class="keyword">yield</span> (j, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    mosaic = Image.<span class="built_in">open</span>(<span class="string">'pixelated_qrcode.bmp'</span>)</span><br><span class="line">    temp = np.asarray(mosaic.copy(), dtype=<span class="string">'uint8'</span>)</span><br><span class="line"></span><br><span class="line">    plans = [ get_initial_plan(mosaic) ]</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> iter_blocks():</span><br><span class="line">        new_plans = []</span><br><span class="line"></span><br><span class="line">        related_block = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> np.ndindex(<span class="number">57</span>, <span class="number">57</span>):</span><br><span class="line">            <span class="keyword">if</span> check_qr_block_in(i, j, x, y):</span><br><span class="line">                related_block.append([x, y])</span><br><span class="line">        n = <span class="built_in">len</span>(related_block)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'Solving (<span class="subst">{i:<span class="number">2</span>}</span>, <span class="subst">{j:<span class="number">2</span>}</span>), related blocks: <span class="subst">{n}</span>'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span> ** n):</span><br><span class="line">            plan = Plan()</span><br><span class="line">            <span class="keyword">for</span> index, block <span class="keyword">in</span> <span class="built_in">enumerate</span>(related_block):</span><br><span class="line">                <span class="keyword">if</span> ((<span class="number">2</span> ** index) &amp; b) &gt; <span class="number">0</span>:</span><br><span class="line">                    paint_with(temp, *block, <span class="number">0</span>)</span><br><span class="line">                    plan.push(*block, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    paint_with(temp, *block, <span class="number">255</span>)</span><br><span class="line">                    plan.push(*block, <span class="number">255</span>)</span><br><span class="line"></span><br><span class="line">            color = calc_block_color(temp, i, j)</span><br><span class="line">            correct_color = mosaic.getpixel((Y + j * BOX_SIZE, X + i * BOX_SIZE))</span><br><span class="line">            <span class="keyword">if</span> color == correct_color:</span><br><span class="line">                <span class="keyword">for</span> old_plan <span class="keyword">in</span> plans:</span><br><span class="line">                    <span class="keyword">if</span> plan.compatible(old_plan):</span><br><span class="line">                        new_plans.append(old_plan.combine(plan))</span><br><span class="line"></span><br><span class="line">        plans = new_plans</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(plans) &gt; <span class="number">1000</span>:</span><br><span class="line">            ids = [ i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plans)) ]</span><br><span class="line">            random.shuffle(ids)</span><br><span class="line">            buckets = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> ids[:<span class="number">1000</span>]:</span><br><span class="line">                buckets.append(plans[i])</span><br><span class="line">            plans = buckets</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(plans) == <span class="number">0</span>:  <span class="comment"># 如果 Failed 了，请洗把脸回来，再跑一遍</span></span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">'Failed'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较炫酷的调试输出</span></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>, <span class="number">52</span>):</span><br><span class="line">            <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>, <span class="number">55</span>):</span><br><span class="line">                <span class="keyword">if</span> (value := plans[<span class="number">0</span>].plan.get((x, y))) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    c = <span class="string">'*'</span> <span class="keyword">if</span> value == <span class="number">0</span> <span class="keyword">else</span> <span class="string">'_'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c = <span class="string">' '</span></span><br><span class="line">                <span class="built_in">print</span>(c, end=<span class="string">' '</span>)</span><br><span class="line">            <span class="built_in">print</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'Current valid plans: <span class="subst">{<span class="built_in">len</span>(plans)}</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出 10 张复原的二维码</span></span><br><span class="line">    <span class="keyword">for</span> i, plan <span class="keyword">in</span> <span class="built_in">enumerate</span>(plans[:<span class="number">10</span>]):</span><br><span class="line">        <span class="keyword">for</span> (x, y), value <span class="keyword">in</span> plan.plan.items():</span><br><span class="line">            paint_with(temp, x, y, value)</span><br><span class="line">        image = Image.fromarray(temp, mode=<span class="string">'L'</span>)</span><br><span class="line">        image.save(<span class="string">f'result-<span class="subst">{i}</span>.bmp'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h1 id="minecraft">minecRaft</h1><p>打开网页，我们发现了一个微型 Minecraft 游戏，<del>然后就开始愉快的摸起鱼来</del>。</p><p>咳咳，这是一道 web 题，并且「本题解法与原版 Minecraft 游戏无关」。故 F12 打开，然后可以看到 html 内嵌的 js 中有这么一段：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cinput.<span class="property">length</span> &gt;= <span class="number">32</span>) {</span><br><span class="line">    <span class="keyword">let</span> tbool = <span class="title function_">gyflagh</span>(cinput.<span class="title function_">join</span>(<span class="string">''</span>));</span><br><span class="line">    <span class="keyword">if</span> (tbool) {</span><br><span class="line">        pressplateList[<span class="number">65</span>].<span class="title class_">TurnOn</span>_redstone_lamp();</span><br><span class="line">        content.<span class="property">innerText</span> = <span class="string">'Congratulations!!!'</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    cinput.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>并且 <code>gyflagh</code> 这个函数是定义在 <code>flag.js</code> 里面的，很难不猜测这就是最终涉及到 flag 的地方。</p><p>打开 <code>flag.js</code>，然后我们看到了一堆乱码…………</p><p>首先我们可以把 <code>0x</code> 打头的十六进制数转成十进制数，不然的话跟变量的命名很像，看着太瞎眼了。</p><p>然后观察一下参数是 <code>422</code> 到 <code>439</code> 之类的函数，可以发现都跟一个叫 <code>_0x2c9e</code> 的函数有关。</p><p>把这个 js 贴到 Devtools Console 里面，多执行几次，发现返回值不会变，并且都是 <code>charCodeAt</code>，<code>slice</code>, <code>fromCharCode</code> 这种函数名，不妨可以猜测这个函数只是一个 string mapping。所以我们就把这个 mapping 手动给它转回去。</p><p>替换完了之后，应该就只剩下变量名比较难看了。所以根据上下文，给这些变量换个名字。</p><p>这波操作下来之后，这个代码就好看了不少：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">String</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">encrypt</span> = <span class="keyword">function</span>(<span class="params">key_str</span>) {</span><br><span class="line">    <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">2</span>), key = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">const</span> plaintext = <span class="built_in">escape</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        key[i] = <span class="title class_">Str4ToLong</span>(key_str.<span class="title function_">slice</span>(i * <span class="number">4</span>, (i + <span class="number">1</span>) * <span class="number">4</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; plaintext.<span class="property">length</span>; i += <span class="number">8</span>) {</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="title class_">Str4ToLong</span>(plaintext.<span class="title function_">slice</span>(i    , i + <span class="number">4</span>));</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="title class_">Str4ToLong</span>(plaintext.<span class="title function_">slice</span>(i + <span class="number">4</span>, i + <span class="number">8</span>));</span><br><span class="line">        <span class="title function_">code</span>(arr, key);</span><br><span class="line">        result += <span class="title class_">LongToBase16</span>(arr[<span class="number">0</span>]) + <span class="title class_">LongToBase16</span>(arr[<span class="number">1</span>]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">code</span>(<span class="params">arr, key</span>) {</span><br><span class="line">    <span class="keyword">let</span> a = arr[<span class="number">0</span>], b = arr[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="variable constant_">STEP</span> = <span class="number">2654435769</span>, <span class="variable constant_">END</span> = <span class="variable constant_">STEP</span> * <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="variable constant_">END</span>) {</span><br><span class="line">        a += ((b &lt;&lt; <span class="number">4</span>) ^ (b &gt;&gt;&gt; <span class="number">5</span>)) + (b ^ cur) + key[cur &amp; <span class="number">3</span>];</span><br><span class="line">        cur += <span class="variable constant_">STEP</span>;</span><br><span class="line">        b += ((a &lt;&lt; <span class="number">4</span>) ^ (a &gt;&gt;&gt; <span class="number">5</span>)) + (a ^ cur) + key[(cur &gt;&gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>];</span><br><span class="line">    }</span><br><span class="line">    arr[<span class="number">0</span>] = a;</span><br><span class="line">    arr[<span class="number">1</span>] = b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Str4ToLong</span>(<span class="params">val</span>) {</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        result |= val.<span class="title function_">charCodeAt</span>(i) &lt;&lt; (i * <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isNaN</span>(result) ? <span class="number">0</span> : result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LongToBase16</span>(<span class="params">val</span>) {</span><br><span class="line">    <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">let</span> tmp = ((val &gt;&gt; (<span class="number">8</span> * i)) &amp; <span class="number">0xff</span>)[<span class="string">'toString'</span>](<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(<span class="string">'0x'</span> + tmp) &lt;= <span class="number">0xf</span>)</span><br><span class="line">            tmp = <span class="string">'0'</span> + tmp;</span><br><span class="line">        result += tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Base16ToLong</span>(<span class="params">str</span>) {</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">2</span>) {</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="built_in">parseInt</span>(<span class="string">'0x'</span> + str.<span class="title function_">slice</span>(i, i + <span class="number">2</span>));</span><br><span class="line">        result = (result &lt;&lt; <span class="number">8</span>) + tmp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">LongToStr4</span>(<span class="params">val</span>) {</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(val &amp; <span class="number">0xff</span>, val &gt;&gt; <span class="number">8</span> &amp; <span class="number">0xff</span>, val &gt;&gt; <span class="number">16</span> &amp; <span class="number">0xff</span>, val &gt;&gt; <span class="number">24</span> &amp; <span class="number">0xff</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">gyflagh</span>(<span class="params">text</span>) {</span><br><span class="line">    <span class="keyword">let</span> encrypted = text.<span class="title function_">encrypt</span>(<span class="string">'1356853149054377'</span>);</span><br><span class="line">    <span class="keyword">return</span> encrypted === <span class="string">'6fbde674819a59bfa12092565b4ca2a7a11dc670c678681daf4afb6704b82f0c'</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们先把目光放在 <code>String.prototype.encrypt</code> 上，这个函数首先将 <code>key_str</code> 分成了 4 段（<code>1356 8531 4905 4377</code>），然后将每一段通过 <code>Str4ToLong</code> 转为整数。</p><p>接着，再把 <code>text</code>（64 个字符，每 8 个分一段）分成 4 段，每一段中再分成前后两个部分（不妨称为 a, b），然后把 a, b 扔给 <code>code</code> 做变换，再把变换后的 a, b <code>LongToBase16</code> 后加到 <code>result</code>（字符串）后面。</p><p>上面这段话可能有点难理解，拿 <code>gyflagh</code> 中的例子来说，假设 <code>text = "mInecRaft#-ls_900d_f0r_$ntEr1ain"</code>，就是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        Str4ToLong                   code                      LongToBase16</span><br><span class="line"></span><br><span class="line">mIne cRaf  -&gt;  1701726573 1717654115  --&gt;   1874716276 -2120590913  -&gt;  6fbde674 819a59bf</span><br><span class="line">t#-l s_90  -&gt;  1814897524 0809066355  --&gt;  -1591700906  1531749031  -&gt;  a1209256 5b4ca2a7</span><br><span class="line">0d_f 0r_$  -&gt;  1717527600 0610234928  --&gt;  -1591884176  -965187555  -&gt;  a11dc670 c678681d</span><br><span class="line">ntEr 1ain  -&gt;  1917154414 1852399921  --&gt;  -1354040473    79179532  -&gt;  af4afb67 04b82f0c</span><br></pre></td></tr></tbody></table></figure><p>但是实际上，<code>text</code> 是什么我们是不知道的，我们要用 <code>encrypted</code> 来反推 <code>text</code>，其关键显然在 <code>code</code> 这个函数中。</p><p>然后现在的话，我们要完成的目标就是（右边的数值可以用 <code>encrypted</code> 进行 <code>Base16ToLong</code> 得到）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">code([?, ?], key)  -&gt;   1874716276 -2120590913</span><br><span class="line">code([?, ?], key)  -&gt;  -1591700906  1531749031</span><br><span class="line">code([?, ?], key)  -&gt;  -1591884176  -965187555</span><br><span class="line">code([?, ?], key)  -&gt;  -1354040473    79179532</span><br></pre></td></tr></tbody></table></figure><p>然后我们可以注意到，<code>code</code> 函数的计算是可逆的，可以通过最终的结果反推出输入的值。</p><p>于是随便写一个逆向程序：</p><figure class="highlight rust"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> KEYS: [Wrapping&lt;<span class="type">u32</span>&gt;; <span class="number">4</span>] = [ <span class="title function_ invoke__">Wrapping</span>(<span class="number">909456177</span>), <span class="title function_ invoke__">Wrapping</span>(<span class="number">825439544</span>), <span class="title function_ invoke__">Wrapping</span>(<span class="number">892352820</span>), <span class="title function_ invoke__">Wrapping</span>(<span class="number">926364468</span>) ];</span><br><span class="line"><span class="keyword">const</span> ADD: Wrapping&lt;<span class="type">u32</span>&gt; = <span class="title function_ invoke__">Wrapping</span>(<span class="number">2654435769</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">uncode</span>(a: <span class="type">u32</span>, b: <span class="type">u32</span>) <span class="punctuation">-&gt;</span> (<span class="type">u32</span>, <span class="type">u32</span>) {</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">val</span> = ADD * <span class="title function_ invoke__">Wrapping</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="title function_ invoke__">Wrapping</span>(a);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">b</span> = <span class="title function_ invoke__">Wrapping</span>(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">_i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">32</span> {</span><br><span class="line">        b -= ((a &lt;&lt; <span class="number">4</span>) ^ (a &gt;&gt; <span class="number">5</span>)) + a ^ val + KEYS[((val &gt;&gt; <span class="number">11</span>).<span class="number">0</span> &amp; <span class="number">3</span>) <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">        val -= ADD;</span><br><span class="line">        a -= ((b &lt;&lt; <span class="number">4</span>) ^ (b &gt;&gt; <span class="number">5</span>)) + b ^ val + KEYS[(val.<span class="number">0</span> &amp; <span class="number">3</span>) <span class="keyword">as</span> <span class="type">usize</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">return</span> (a.<span class="number">0</span>, b.<span class="number">0</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后就不难推算出 <code>code</code> 的输入是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ 1700225869, 1598378594 ]</span><br><span class="line">[ 1817013865, 1098007406 ]</span><br><span class="line">[  861893681, 1601779041 ]</span><br><span class="line">[ 1967743793, 1765372015 ]</span><br></pre></td></tr></tbody></table></figure><p>然后再把这些值用 <code>LongToStr4</code> 拼回去，得到 <code>McWebRE_inMlnCrA1t_3a5y_1cIuop9i</code>。</p><h1 id="密码生成器">密码生成器</h1><p>运行密码生成器，发现并没有输入栏；并且能够感觉到，这道题是要“复现”输出。</p><p>然后，我们可以盲猜……这个程序的“输入”是，时间，精度大约是 1 秒。</p><p>然后的话，我们就可以把时间设置成 2021-09-22 23:11（也可以用 <a href="https://www.nirsoft.net/utils/run_as_date.html">RunAsDate</a>）（感觉那个时区只是一个障眼法），然后生成一些密码，多试几个，就成了。</p><p>密码是 <code>$Z=CBDL7TjHu~mEX</code>，登入就能获取 flag 了。</p><p>顺带一说，为了更方便手操（cao 一声），我还弄了一个自动读剪贴板的东西，这样鼠标就只用点“生成”、“复制到剪贴板”了。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> win32clipboard</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">s = <span class="built_in">set</span>()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            win32clipboard.OpenClipboard()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception:  <span class="comment"># 上面的 OpenClipboard 有概率出错，盲猜是读写冲突了</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    data = win32clipboard.GetClipboardData()</span><br><span class="line">    win32clipboard.CloseClipboard()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data <span class="keyword">not</span> <span class="keyword">in</span> s:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f'new data: <span class="subst">{data}</span>'</span>)</span><br><span class="line">        s.add(data)</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br></pre></td></tr></tbody></table></figure><h1 id="just-be-fun">JUST BE FUN</h1><blockquote><p>写在前面：这道题有更好的解法，甚至可以两维完成。我这里的话，首先是当时也没想那么多，基本上是“能跑就行”，其次我以为交换只能交换栈顶两个数，这个就限制了很多可能。所以这个解法看个乐就行。</p></blockquote><p>说实话，这道题还是蛮有意思的。怎么说呢，看着自己写的指令在三维空间上执行，虽然实际上没有什么用，但是看起来炫酷就完事了。</p><p>这道题的大致意思就是，你可以在一个三维（256 * 256 * 256）的空间（可以看成是地址）上写程序（每个点能写一个指令），然后解析器会在上面跑。同时解析器会随机生成一个求值字符串，需要你编写一个能正确算出这个值的程序。</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: center;">机器码</th><th style="text-align: center;">读取数</th><th style="text-align: center;">写入数</th><th>含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">ADD_OP</td><td style="text-align: center;"><code>+</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>将栈顶两个数相加</td></tr><tr class="even"><td style="text-align: center;">SUB_OP</td><td style="text-align: center;"><code>-</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>将栈顶两个数相减（栈顶为减数）</td></tr><tr class="odd"><td style="text-align: center;">MUL_OP</td><td style="text-align: center;"><code>*</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>将栈顶两个数相乘</td></tr><tr class="even"><td style="text-align: center;">DIV_OP</td><td style="text-align: center;"><code>/</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>将栈顶两个数相除（栈顶为除数）</td></tr><tr class="odd"><td style="text-align: center;">MOD_OP</td><td style="text-align: center;"><code>%</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>将栈顶两个数取模（栈顶为模数）</td></tr><tr class="even"><td style="text-align: center;">NOT_OP</td><td style="text-align: center;"><code>!</code></td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td>取非</td></tr><tr class="odd"><td style="text-align: center;">CMP_OP</td><td style="text-align: center;"><code>`</code></td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td>比较，栈顶小则 1，否则为 0</td></tr><tr class="even"><td style="text-align: center;">X_U_OP</td><td style="text-align: center;"><code>&gt;</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 x+ 运行</td></tr><tr class="odd"><td style="text-align: center;">X_D_OP</td><td style="text-align: center;"><code>&lt;</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 x- 运行</td></tr><tr class="even"><td style="text-align: center;">Y_U_OP</td><td style="text-align: center;"><code>v</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 y+ 运行</td></tr><tr class="odd"><td style="text-align: center;">Y_D_OP</td><td style="text-align: center;"><code>^</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 y- 运行</td></tr><tr class="even"><td style="text-align: center;">Z_U_OP</td><td style="text-align: center;"><code>[</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 z+ 运行</td></tr><tr class="odd"><td style="text-align: center;">Z_D_OP</td><td style="text-align: center;"><code>]</code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>向 z- 运行</td></tr><tr class="even"><td style="text-align: center;">X_JMP</td><td style="text-align: center;"><code>_</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>若栈顶为 <code>True</code>，则向 x- 运行，反之亦然</td></tr><tr class="odd"><td style="text-align: center;">Y_JMP</td><td style="text-align: center;"><code>|</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>若栈顶为 <code>True</code>，则向 y- 运行，反之亦然</td></tr><tr class="even"><td style="text-align: center;">Z_JMP</td><td style="text-align: center;"><code>#</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>若栈顶为 <code>True</code>，则向 z- 运行，反之亦然</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: center;"><code>"</code></td><td style="text-align: center;">0</td><td style="text-align: center;">n</td><td>将此处（不含 <code>"</code>）到下一个 <code>"</code> 之前的指令，都作为 ASCII 写入栈中</td></tr><tr class="even"><td style="text-align: center;">DUP_OP</td><td style="text-align: center;"><code>:</code></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td>将栈顶元素复制多一份</td></tr><tr class="odd"><td style="text-align: center;">SWAP_OP</td><td style="text-align: center;"><code>\</code></td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td>将两个指定位置的值交换（位置为相对于栈顶，不计这两个操作数，从 1 开始）</td></tr><tr class="even"><td style="text-align: center;">POP_OP</td><td style="text-align: center;"><code>$</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>弹出栈顶一个元素</td></tr><tr class="odd"><td style="text-align: center;">NUM_OP</td><td style="text-align: center;"><code>.</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>将栈顶作为数字写入 <code>result</code></td></tr><tr class="even"><td style="text-align: center;">CHR_OP</td><td style="text-align: center;"><code>,</code></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td>将栈顶作为 ASCII 写入 <code>result</code></td></tr><tr class="odd"><td style="text-align: center;">INP_OP</td><td style="text-align: center;"><code>~</code></td><td style="text-align: center;">0</td><td style="text-align: center;">1</td><td>读取 <code>input</code> 序列的下一个字符，为 ASCII 码</td></tr><tr class="even"><td style="text-align: center;">END_OP</td><td style="text-align: center;"><code>@</code></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td>程序结束</td></tr><tr class="odd"><td style="text-align: center;">NOP_OP</td><td style="text-align: center;"><code></code></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td>什么都不做（按照惯性继续向前）</td></tr></tbody></table><p>并且已知程序从 <code>[0, 0, 0]</code> 开始执行，方向为 <code>[1, 0, 0]</code>（x+）。</p><p>输入序列是像 <code>6*2|2*4&lt;2*6*1x7^4|3</code> 一类的字符串，运算符没有优先级（都是从左向右），数字都是 1 位数字。运算符具体含义如下：</p><table><thead><tr class="header"><th style="text-align: center;">运算符</th><th style="text-align: center;">ASCII</th><th style="text-align: left;">含义</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>+</code></td><td style="text-align: center;">43</td><td style="text-align: left;">加法</td></tr><tr class="even"><td style="text-align: center;"><code>*</code></td><td style="text-align: center;">42</td><td style="text-align: left;">乘法</td></tr><tr class="odd"><td style="text-align: center;"><code>^</code></td><td style="text-align: center;">94</td><td style="text-align: left;">幂运算</td></tr><tr class="even"><td style="text-align: center;"><code>x</code></td><td style="text-align: center;">120</td><td style="text-align: left;">二进制异或（XOR）</td></tr><tr class="odd"><td style="text-align: center;"><code>|</code></td><td style="text-align: center;">124</td><td style="text-align: left;">二进制或（OR）</td></tr><tr class="even"><td style="text-align: center;"><code>&lt;</code></td><td style="text-align: center;">60</td><td style="text-align: left;">二进制左移</td></tr></tbody></table><p>于是我们可以大致确定这个程序的框架：</p><ol type="1"><li>先获取第一个数字，压入栈中，作为初始数值；</li><li>获取下一个输入（运算符），然后分发到不同的代码段中执行；</li><li>重复第 2 个操作，直到遇到 <code>\0</code>。</li></ol><p>于是我们可以设计这么一种 layout：</p><p><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_layout.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_layout.png" loading="lazy"></a></p><p>注意到运算符的顺序，按照 ASCII 来排序可以方便后面的比较操作（只需要比较 <code>&gt;</code> 一次就可以了，不用反过来再比一次）。</p><p>至于每一层，反正它给了 256 格高，我直接给每一层分配了 16 格的高度，让它们自由发挥，避免上下冲突。</p><p>下面我们来分别设计这些部分，目录：</p><ul><li><a href="#useful-patterns">Useful Patterns</a> (Pre-requisite knowledge)</li><li><a href="#program-entrypoint">Program Entrypoint</a></li><li><a href="#command-dispatcher-returner">Command Dispatcher &amp; Returner</a></li><li><a href="#binocular-operator">Binocular Operator (Add, Multiple)</a></li><li><a href="#power-and-shift-operator">Power and Shift Operator</a></li><li><a href="#bitwise-operator">Bitwise Operator (XOR, OR)</a></li></ul><h2 id="useful-patterns">Useful Patterns</h2><p>在开始之前，我们先定义一些常用操作的 patterns。</p><h3 id="比较栈顶位置与一个常数09">比较栈顶位置与一个常数（0~9）</h3><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">DUP_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">栈顶元素需要保留，而比较指令会消耗参数，故复制一份</td></tr><tr class="odd"><td style="text-align: center;">0~9</td><td style="text-align: left;"><code>[ val, val, 0~9 ]</code></td><td style="text-align: left;">需要比较的常数</td></tr><tr class="even"><td style="text-align: center;">CMP_OP</td><td style="text-align: left;"><code>[ val, 0/1 ]</code></td><td style="text-align: left;">进行比较，并且把比较结果放到栈顶</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;">自定义跳转</td></tr><tr class="even"><td style="text-align: center;">POP_OP</td><td style="text-align: left;"><code>[]</code></td><td style="text-align: left;"><strong>如果</strong>整个匹配过程结束（<code>val</code> 不再需要）</td></tr></tbody></table><h3 id="比较栈顶位置与一个常数超出-09">比较栈顶位置与一个常数（超出 0~9）</h3><p>如果范围超出了 0~9，就要考虑用字符串模式将比较常数压入栈中。</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">DUP_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">栈顶元素需要保留，而比较指令会消耗参数，故复制一份</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">进入字符串模式</td></tr><tr class="even"><td style="text-align: center;">x</td><td style="text-align: left;"><code>[ val, val, 'x' ]</code></td><td style="text-align: left;">需要比较的常数（比 9 大的数可以找 ASCII 后面的字母）</td></tr><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: left;"><code>[ val, val, 'x', '0' ]</code></td><td style="text-align: left;">用来后面做减法</td></tr><tr class="even"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val, 'x', '0' ]</code></td><td style="text-align: left;">退出字符串模式</td></tr><tr class="odd"><td style="text-align: center;">SUB_OP</td><td style="text-align: left;"><code>[ val, val, x ]</code></td><td style="text-align: left;">减一下，获得真实数字</td></tr><tr class="even"><td style="text-align: center;">CMP_OP</td><td style="text-align: left;"><code>[ val, 0/1 ]</code></td><td style="text-align: left;">进行比较，并且把比较结果放到栈顶</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;">自定义跳转</td></tr><tr class="even"><td style="text-align: center;">POP_OP</td><td style="text-align: left;"><code>[]</code></td><td style="text-align: left;"><strong>如果</strong>整个匹配过程结束（<code>val</code> 不再需要）</td></tr></tbody></table><h3 id="比较栈顶位置与一个字符">比较栈顶位置与一个字符</h3><p>跟上一个相比，不用压入 <code>0</code> 了。</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">DUP_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">栈顶元素需要保留，而比较指令会消耗参数，故复制一份</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">进入字符串模式</td></tr><tr class="even"><td style="text-align: center;">x</td><td style="text-align: left;"><code>[ val, val, 'x' ]</code></td><td style="text-align: left;">需要比较的字符</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val, 'x' ]</code></td><td style="text-align: left;">退出字符串模式</td></tr><tr class="even"><td style="text-align: center;">CMP_OP</td><td style="text-align: left;"><code>[ val, 0/1 ]</code></td><td style="text-align: left;">进行比较，并且把比较结果放到栈顶</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;">自定义跳转</td></tr><tr class="even"><td style="text-align: center;">POP_OP</td><td style="text-align: left;"><code>[]</code></td><td style="text-align: left;"><strong>如果</strong>整个匹配过程结束（<code>val</code> 不再需要）</td></tr></tbody></table><h3 id="交换栈顶两个元素">交换栈顶两个元素</h3><p>因为我一开始以为只能交换栈顶两个元素，等到实现到最后才发现不是。反正无伤大雅，加两个操作数就完事了。</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ v1, v2 ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: left;"><code>[ v1, v2, 1 ]</code></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: left;"><code>[ v1, v2, 1, 2 ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">CMP_OP</td><td style="text-align: left;"><code>[ v2, v1 ]</code></td><td style="text-align: left;">观察 <code>be_fun.py</code> 代码，易得</td></tr></tbody></table><h2 id="program-entrypoint">Program Entrypoint</h2><p><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_entrypoint.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_entrypoint.png" loading="lazy"></a></p><p>如图所示，获取第一个数字然后减去 <code>0</code>，然后向上跳转，将控制权交给 Dispatcher。</p><p>注意到这里还有一个 Returner，其实只是复用了一下这个 <code>[</code> 字符，将 <code>[</code> 看成两部分共用的即可。</p><h2 id="command-dispatcher-returner">Command Dispatcher &amp; Returner</h2><blockquote><p>这一 section 的指令全部都是放在 <code>y=0</code> 中。</p></blockquote><p><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_dispatcher_1.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_dispatcher_1.png" loading="lazy"></a></p><p>左下角的地址，可以看作是新一轮运算执行的开始（后面 Returner 也会返回到这个位置）。</p><p>所以先获取这一轮的运算符，然后判断是不是 0，是 0 的话就写出结果，然后退出程序。</p><p>否则就向 z+ 运行，到对应 Command 的 layer 的时候，就比较一下运算符，比较成功就跳转进去（y+）。</p><p>比较器如下所示，其中 <code>+*^&lt;|x</code> 为这一层的 Command，根据情况安排：</p><p><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_dispatcher_2.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_dispatcher_2.png" loading="lazy"></a></p><p>至于 Returner 的话，我就直接在 <code>x=245, y=0</code> 的地方安排一条 Z_D_OP 的返回通道，指令运行完就跳到这个位置就行。</p><p>然后在 <code>z=0, y=0</code> 的地方，再安排一条返回 <code>[5, 0, 0]</code> 的 X_D_OP 通道（返回到 Entrypoint 的 from Returner 的地方，然后进入下一轮运算）</p><p>其实这个怎么搞也没有太大关系，先把标准弄好，后面对接的时候就会比较方便。</p><h2 id="binocular-operator">Binocular Operator</h2><p>加法和乘法比较简单，甚至指令都是一维的，就不画图了。</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;">注意到运算符已经被提前 POP 出去了</td></tr><tr class="even"><td style="text-align: center;">INP_OP</td><td style="text-align: left;"><code>[ val, 'x' ]</code></td><td style="text-align: left;">获取运算数</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, 'x' ]</code></td><td style="text-align: left;">进入字符串模式</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: left;"><code>[ val, 'x', '0' ]</code></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, 'x', '0' ]</code></td><td style="text-align: left;">退出字符串模式</td></tr><tr class="even"><td style="text-align: center;">SUB_OP</td><td style="text-align: left;"><code>[ val, x ]</code></td><td style="text-align: left;">因为前面的 <code>x</code> 是字符，需要减一个 <code>0</code></td></tr><tr class="odd"><td style="text-align: center;"><code>+</code> or <code>*</code></td><td style="text-align: left;"><code>[ res ]</code></td><td style="text-align: left;">进行加法/乘法操作</td></tr></tbody></table><p>这堆操作搞完了之后，就直接导航到 <code>x=245, y=0</code> 处就不用管了（控制权交给 Returner）。</p><h2 id="power-and-shift-operator">Power and Shift Operator</h2><p>这一段的操作主要是左移和幂。思考一下，虽然可以写一个简单循环，但是仔细想一下，发现细节还是挺多的，于是我就换了一个思路。</p><p>考虑到操作数只有 1 到 9 的范围，所以可以把这些把这些情况分开考虑（分别安排电路）。</p><p>对于左移操作，如果要左移 <code>x</code> 位的话，等价于乘上 <code>x</code> 个 2，于是我们就可以先压入 <code>x</code> 个 2，再执行 <code>x</code> 次乘法操作。</p><p>对于幂运算，就是把当前的 <code>val</code> 复制出 <code>x</code> 份，然后再执行 <code>x - 1</code> 次乘法即可。</p><p><a href="/images/2021-10-30-Hackergame-2021/JustBeFun-shift.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun-shift.png" loading="lazy"></a></p><p>上面划出来点部分可以往后堆叠，<del>我本来想做成单片的，但是没做成</del>。注意到这里的 <code>n</code> 是从小到大（即 1~9）排的。</p><p>对于幂操作也类似，在中间竖条的地方改成 DUP_OP 和 MUL_OP（都是 <code>x - 1</code> 次）即可。</p><h2 id="bitwise-operator">Bitwise Operator</h2><p>这个位运算，我一开始在想，怎么用加减乘除模这些运算凑出来一个位运算啊。然后想不出来（也可能是我太菜了）。</p><p>如果不能凑的话，考虑到操作数只有 1~9，最多就是二进制的低 4 位，也就是说，对于左操作数，只用考虑它的低 4 位就行了（0~15）。</p><p>然后掐指一算，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>9</mn><mo>×</mo><mn>16</mn><mo>=</mo><mn>144</mn></mrow><annotation encoding="application/x-tex">9 16 = 144</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">9</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">4</span><span class="mord">4</span></span></span></span>，感觉打个表完全可以接受啊，整个地址空间每维有 256 个长度，完全够用。</p><p>也就是说，我们首先要把左操作数的低 4 位提取出来，跟右操作数一起寻址（打表）（实际上为了方便起见，这两个部分分开寻址），然后找到结果之后再跟原数的高位结合，就可以了。</p><p>先把大框架搭起来，先把左操作数 <code>val</code> 拆成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>16</mn><mi>a</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">16a + b</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 的形式（为了可读性，这里省略掉一些重复的部分）：</p><table><thead><tr class="header"><th style="text-align: center;">指令</th><th style="text-align: left;">栈</th><th style="text-align: left;">备注</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: left;"><code>[ val ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">DUP_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">复制一份，毕竟要拆成两个数</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val ]</code></td><td style="text-align: left;">进入字符串模式</td></tr><tr class="even"><td style="text-align: center;">'0' + 16</td><td style="text-align: left;"><code>[ val, val, '@' ]</code></td><td style="text-align: left;">因为 16 超出了 0~9，只能这样干了</td></tr><tr class="odd"><td style="text-align: center;">'0'</td><td style="text-align: left;"><code>[ val, val, '@', '0' ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ val, val, '@', '0' ]</code></td><td style="text-align: left;">退出字符串模式</td></tr><tr class="odd"><td style="text-align: center;">SUB_OP</td><td style="text-align: left;"><code>[ val, val, 16 ]</code></td><td style="text-align: left;">减一下，获得真正的 16</td></tr><tr class="even"><td style="text-align: center;">DIV_OP</td><td style="text-align: left;"><code>[ val, a ]</code></td><td style="text-align: left;">除一下，获得 <code>a</code></td></tr><tr class="odd"><td style="text-align: center;">1, 2, SWAP_OP</td><td style="text-align: left;"><code>[ a, val ]</code></td><td style="text-align: left;">交换栈顶俩元素</td></tr><tr class="even"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ a, val ]</code></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: center;">*</td><td style="text-align: left;"><code>[ a, val, 16 ]</code></td><td style="text-align: left;">自行用 STR 压入 16（参考上面）</td></tr><tr class="even"><td style="text-align: center;">MOD_OP</td><td style="text-align: left;"><code>[ a, b ]</code></td><td style="text-align: left;">模一下，获得 <code>b</code></td></tr><tr class="odd"><td style="text-align: center;">... (P1)</td><td style="text-align: left;"><code>[ a ]</code></td><td style="text-align: left;">把 <code>b</code> 拿去匹配（寻址）</td></tr><tr class="even"><td style="text-align: center;">INP_OP</td><td style="text-align: left;"><code>[ a, 'x' ]</code></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: center;">*</td><td style="text-align: left;"><code>[ a, x ]</code></td><td style="text-align: left;">自行减 <code>0</code></td></tr><tr class="even"><td style="text-align: center;">... (P2)</td><td style="text-align: left;"><code>[ a ]</code></td><td style="text-align: left;">把 <code>x</code> 拿去匹配</td></tr><tr class="odd"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ a ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">'0' + r</td><td style="text-align: left;"><code>[ a, 'r' ]</code></td><td style="text-align: left;">打表结果</td></tr><tr class="odd"><td style="text-align: center;">'0'</td><td style="text-align: left;"><code>[ a, 'r', '0' ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">STR_OP</td><td style="text-align: left;"><code>[ a, 'r', '0' ]</code></td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: center;">SUB_OP</td><td style="text-align: left;"><code>[ a, r ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">...</td><td style="text-align: left;"></td><td style="text-align: left;">这里可以先返回，后面的内容可以复用</td></tr><tr class="odd"><td style="text-align: center;">1, 2, SWAP_OP</td><td style="text-align: left;"><code>[ r, a ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">*</td><td style="text-align: left;"><code>[ r, a, 16 ]</code></td><td style="text-align: left;">自行用 STR 压入 16（参考上面）</td></tr><tr class="odd"><td style="text-align: center;">MUL_OP</td><td style="text-align: left;"><code>[ r, a * 16 ]</code></td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: center;">ADD_OP</td><td style="text-align: left;"><code>[ a * 16 + r ]</code></td><td style="text-align: left;"></td></tr></tbody></table><p>然后把子 dispatcher（P1、P2）写好就行了。由于打表，2 个变量就要用掉 2 维，还有一维要放匹配完后执行的指令，所以以下三维灵魂抽象画警告。</p><figure><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_layout.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_layout.png" alt="" loading="lazy"></a><figcaption>Layout</figcaption></figure><figure><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_p1.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_p1.png" alt="" loading="lazy"></a><figcaption>P1</figcaption></figure><figure><a href="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_p2.png" class="glightbox"><img src="/images/2021-10-30-Hackergame-2021/JustBeFun_bitwise_p2.png" alt="" loading="lazy"></a><figcaption>P2</figcaption></figure><p>大概就是这个样子，相信大家都能看懂吧（）。</p><p>最后把所有的部分拼起来，就成了。代码呢，就是这个样子：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">TOKEN = <span class="string">'1:MEQCIBY0ubN3BOXYsuRdXzqWIWNf8Jx0Y6giZCSp/Rg8zdNwAiBMZGWaiIGLD33KTfQ5TTLejp9PwGp8Gg4HsJbdo8sVig=='</span></span><br><span class="line"></span><br><span class="line">ADD_OP = <span class="string">'+'</span></span><br><span class="line">SUB_OP = <span class="string">'-'</span></span><br><span class="line">MUL_OP = <span class="string">'*'</span></span><br><span class="line">DIV_OP = <span class="string">'/'</span></span><br><span class="line">MOD_OP = <span class="string">'%'</span></span><br><span class="line">CMP_OP = <span class="string">'`'</span></span><br><span class="line">X_U_OP = <span class="string">'&gt;'</span></span><br><span class="line">X_D_OP = <span class="string">'&lt;'</span></span><br><span class="line">Y_D_OP = <span class="string">'^'</span></span><br><span class="line">Y_U_OP = <span class="string">'v'</span></span><br><span class="line">Z_U_OP = <span class="string">'['</span></span><br><span class="line">Z_D_OP = <span class="string">']'</span></span><br><span class="line">X_JMP = <span class="string">'_'</span></span><br><span class="line">Z_JMP = <span class="string">'#'</span></span><br><span class="line">STR_OP = <span class="string">'\"'</span></span><br><span class="line">DUP_OP = <span class="string">':'</span></span><br><span class="line">SWAP_OP = <span class="string">'\\'</span></span><br><span class="line">POP_OP = <span class="string">'$'</span></span><br><span class="line">NUM_OP = <span class="string">'.'</span></span><br><span class="line">INP_OP = <span class="string">'~'</span></span><br><span class="line">END_OP = <span class="string">'@'</span></span><br><span class="line">NOP_OP = <span class="string">' '</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">NUM</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">chr</span>(x + <span class="built_in">ord</span>(<span class="string">'0'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">board = [[[<span class="string">'@'</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>)] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>)]</span><br><span class="line"></span><br><span class="line">BLOCK_START = <span class="number">0x20</span></span><br><span class="line">BLOCK_HEIGHT = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">SUB_COMMAND = {</span><br><span class="line">    <span class="string">'*'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">1</span>, <span class="comment"># 42</span></span><br><span class="line">    <span class="string">'+'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">2</span>, <span class="comment"># 43</span></span><br><span class="line">    <span class="string">'&lt;'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">3</span>, <span class="comment"># 60</span></span><br><span class="line">    <span class="string">'^'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">4</span>, <span class="comment"># 94</span></span><br><span class="line">    <span class="string">'x'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">5</span>, <span class="comment"># 120</span></span><br><span class="line">    <span class="string">'|'</span>: BLOCK_START + BLOCK_HEIGHT * <span class="number">6</span>, <span class="comment"># 124</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_init</span>():</span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([INP_OP, STR_OP, <span class="string">'0'</span>, STR_OP, SUB_OP, Z_U_OP]):</span><br><span class="line">        board[i][<span class="number">0</span>][<span class="number">0</span>] = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_command_dispatcher</span>():</span><br><span class="line">    board[ <span class="number">5</span>][<span class="number">0</span>][<span class="number">1</span>] = X_U_OP</span><br><span class="line">    board[ <span class="number">6</span>][<span class="number">0</span>][<span class="number">1</span>] = INP_OP</span><br><span class="line">    board[ <span class="number">7</span>][<span class="number">0</span>][<span class="number">1</span>] = DUP_OP</span><br><span class="line">    board[ <span class="number">8</span>][<span class="number">0</span>][<span class="number">1</span>] = NUM(<span class="number">0</span>)</span><br><span class="line">    board[ <span class="number">9</span>][<span class="number">0</span>][<span class="number">1</span>] = CMP_OP</span><br><span class="line">    board[<span class="number">10</span>][<span class="number">0</span>][<span class="number">1</span>] = Z_U_OP</span><br><span class="line">    board[<span class="number">10</span>][<span class="number">0</span>][<span class="number">2</span>] = X_JMP</span><br><span class="line">    board[ <span class="number">9</span>][<span class="number">0</span>][<span class="number">2</span>] = Z_U_OP</span><br><span class="line"></span><br><span class="line">    board[<span class="number">11</span>][<span class="number">0</span>][<span class="number">2</span>] = POP_OP</span><br><span class="line">    board[<span class="number">12</span>][<span class="number">0</span>][<span class="number">2</span>] = NUM_OP</span><br><span class="line">    board[<span class="number">13</span>][<span class="number">0</span>][<span class="number">2</span>] = END_OP</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[ <span class="number">9</span>][<span class="number">0</span>][z] = NOP_OP</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (cmd, pos) <span class="keyword">in</span> SUB_COMMAND.items():</span><br><span class="line">        <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([DUP_OP, STR_OP, cmd, STR_OP, CMP_OP]):</span><br><span class="line">            board[<span class="number">9</span>][<span class="number">0</span>][pos - (<span class="number">5</span> - i)] = c</span><br><span class="line">        board[<span class="number">9</span>][<span class="number">0</span>][pos] = X_JMP</span><br><span class="line">        board[<span class="number">10</span>][<span class="number">0</span>][pos] = POP_OP</span><br><span class="line">        board[<span class="number">11</span>][<span class="number">0</span>][pos] = Y_U_OP</span><br><span class="line">        board[<span class="number">8</span>][<span class="number">0</span>][pos] = Z_U_OP</span><br><span class="line">        board[<span class="number">8</span>][<span class="number">0</span>][pos + <span class="number">1</span>] = X_U_OP</span><br><span class="line">        board[<span class="number">9</span>][<span class="number">0</span>][pos + <span class="number">1</span>] = Z_U_OP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_returner</span>():</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>( <span class="number">6</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[x][<span class="number">0</span>][<span class="number">0</span>] = X_D_OP</span><br><span class="line">    <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[<span class="number">0x100</span> - <span class="number">10</span>][<span class="number">0</span>][z] = Z_D_OP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_binocular_operator</span>(<span class="params">cmd, op</span>):</span><br><span class="line">    Z_BASE = SUB_COMMAND[cmd]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([X_U_OP, INP_OP, STR_OP, NUM(<span class="number">0</span>), STR_OP, SUB_OP, op]):</span><br><span class="line">        board[<span class="number">11</span> + i][<span class="number">1</span>][Z_BASE] = c</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[x][<span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">    board[<span class="number">0x100</span> - <span class="number">10</span>][<span class="number">1</span>][Z_BASE] = Y_D_OP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_pow_operator</span>():</span><br><span class="line">    Z_BASE = SUB_COMMAND[<span class="string">'^'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([NOP_OP, INP_OP, STR_OP, NUM(<span class="number">0</span>), STR_OP, SUB_OP]):</span><br><span class="line">        board[<span class="number">11</span>][i + <span class="number">1</span>][Z_BASE] = c</span><br><span class="line"></span><br><span class="line">    board[<span class="number">11</span>][<span class="number">7</span>][Z_BASE] = X_D_OP</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span> + <span class="number">1</span>):</span><br><span class="line">        y = (i - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">7</span></span><br><span class="line">        board[<span class="number">10</span>][y    ][Z_BASE] = DUP_OP</span><br><span class="line">        board[ <span class="number">9</span>][y    ][Z_BASE] = NUM(i)</span><br><span class="line">        board[ <span class="number">8</span>][y    ][Z_BASE] = Y_U_OP</span><br><span class="line">        board[ <span class="number">8</span>][y + <span class="number">1</span>][Z_BASE] = X_U_OP</span><br><span class="line">        board[ <span class="number">9</span>][y + <span class="number">1</span>][Z_BASE] = CMP_OP</span><br><span class="line">        board[<span class="number">10</span>][y + <span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">1</span>][Z_BASE] = Y_U_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">2</span>][Z_BASE] = X_JMP</span><br><span class="line">        board[<span class="number">12</span>][y + <span class="number">2</span>][Z_BASE] = POP_OP</span><br><span class="line"></span><br><span class="line">        x = <span class="number">13</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>):</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = DUP_OP</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - <span class="number">1</span>):</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = MUL_OP</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; <span class="number">0x100</span>:</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = NOP_OP</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[<span class="number">0x100</span> - <span class="number">10</span>][y][Z_BASE] = Y_D_OP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_shift_operator</span>():</span><br><span class="line">    Z_BASE = SUB_COMMAND[<span class="string">'&lt;'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([NOP_OP, INP_OP, STR_OP, NUM(<span class="number">0</span>), STR_OP, SUB_OP]):</span><br><span class="line">        board[<span class="number">11</span>][i + <span class="number">1</span>][Z_BASE] = c</span><br><span class="line"></span><br><span class="line">    board[<span class="number">11</span>][<span class="number">7</span>][Z_BASE] = X_D_OP</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span> + <span class="number">1</span>):</span><br><span class="line">        y = (i - <span class="number">1</span>) * <span class="number">2</span> + <span class="number">7</span></span><br><span class="line">        board[<span class="number">10</span>][y    ][Z_BASE] = DUP_OP</span><br><span class="line">        board[ <span class="number">9</span>][y    ][Z_BASE] = NUM(i)</span><br><span class="line">        board[ <span class="number">8</span>][y    ][Z_BASE] = Y_U_OP</span><br><span class="line">        board[ <span class="number">8</span>][y + <span class="number">1</span>][Z_BASE] = X_U_OP</span><br><span class="line">        board[ <span class="number">9</span>][y + <span class="number">1</span>][Z_BASE] = CMP_OP</span><br><span class="line">        board[<span class="number">10</span>][y + <span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">1</span>][Z_BASE] = Y_U_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">2</span>][Z_BASE] = X_JMP</span><br><span class="line">        board[<span class="number">12</span>][y + <span class="number">2</span>][Z_BASE] = POP_OP</span><br><span class="line"></span><br><span class="line">        x = <span class="number">13</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = NUM(<span class="number">2</span>)</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = MUL_OP</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> x &lt; <span class="number">0x100</span>:</span><br><span class="line">            board[x][y + <span class="number">2</span>][Z_BASE] = NOP_OP</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[<span class="number">0x100</span> - <span class="number">10</span>][y][Z_BASE] = Y_D_OP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_bitwise_operator</span>(<span class="params">cmd, calc</span>):</span><br><span class="line">    Z_BASE = SUB_COMMAND[cmd]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([DUP_OP, STR_OP, NUM(<span class="number">16</span>), NUM(<span class="number">0</span>), STR_OP, SUB_OP, DIV_OP, NUM(<span class="number">1</span>), NUM(<span class="number">2</span>), SWAP_OP,</span><br><span class="line">                             STR_OP, NUM(<span class="number">16</span>), NUM(<span class="number">0</span>), STR_OP, SUB_OP, MOD_OP]):</span><br><span class="line">        board[<span class="number">11</span>][i + <span class="number">1</span>][Z_BASE] = c</span><br><span class="line"></span><br><span class="line">    board[<span class="number">11</span>][<span class="number">17</span>][Z_BASE] = X_D_OP</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">16</span>):</span><br><span class="line">        y = i * <span class="number">2</span> + <span class="number">17</span></span><br><span class="line">        board[<span class="number">10</span>][y][Z_BASE] = DUP_OP</span><br><span class="line">        board[ <span class="number">9</span>][y][Z_BASE] = STR_OP</span><br><span class="line">        board[ <span class="number">8</span>][y][Z_BASE] = NUM(i)</span><br><span class="line">        board[ <span class="number">7</span>][y][Z_BASE] = NUM(<span class="number">0</span>)</span><br><span class="line">        board[ <span class="number">6</span>][y][Z_BASE] = STR_OP</span><br><span class="line">        board[ <span class="number">5</span>][y][Z_BASE] = Y_U_OP</span><br><span class="line">        board[ <span class="number">5</span>][y + <span class="number">1</span>][Z_BASE] = X_U_OP</span><br><span class="line">        board[ <span class="number">6</span>][y + <span class="number">1</span>][Z_BASE] = SUB_OP</span><br><span class="line">        board[ <span class="number">7</span>][y + <span class="number">1</span>][Z_BASE] = CMP_OP</span><br><span class="line">        board[ <span class="number">8</span>][y + <span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">        board[ <span class="number">9</span>][y + <span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">        board[<span class="number">10</span>][y + <span class="number">1</span>][Z_BASE] = NOP_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">1</span>][Z_BASE] = Y_U_OP</span><br><span class="line">        board[<span class="number">11</span>][y + <span class="number">2</span>][Z_BASE] = X_JMP</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([POP_OP, INP_OP, STR_OP, NUM(<span class="number">0</span>), STR_OP, SUB_OP]):</span><br><span class="line">            board[<span class="number">12</span> + i][y + <span class="number">2</span>][Z_BASE] = c</span><br><span class="line"></span><br><span class="line">        y_base = y + <span class="number">2</span></span><br><span class="line">        board[<span class="number">18</span>][y_base][Z_BASE] = Z_D_OP</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">9</span> + <span class="number">1</span>):</span><br><span class="line">            x = (j - <span class="number">1</span>) * <span class="number">2</span> + (<span class="number">18</span>)</span><br><span class="line">            board[x    ][y_base][Z_BASE - <span class="number">1</span>] = DUP_OP</span><br><span class="line">            board[x    ][y_base][Z_BASE - <span class="number">2</span>] = NUM(j)</span><br><span class="line">            board[x    ][y_base][Z_BASE - <span class="number">3</span>] = X_U_OP</span><br><span class="line">            board[x + <span class="number">1</span>][y_base][Z_BASE - <span class="number">3</span>] = Z_U_OP</span><br><span class="line">            board[x + <span class="number">1</span>][y_base][Z_BASE - <span class="number">2</span>] = CMP_OP</span><br><span class="line">            board[x + <span class="number">1</span>][y_base][Z_BASE - <span class="number">1</span>] = NOP_OP</span><br><span class="line">            board[x + <span class="number">1</span>][y_base][Z_BASE    ] = X_U_OP</span><br><span class="line">            board[x + <span class="number">2</span>][y_base][Z_BASE    ] = Z_JMP</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([POP_OP, STR_OP, NUM(calc(i, j)), NUM(<span class="number">0</span>), STR_OP, SUB_OP]):</span><br><span class="line">                board[x + <span class="number">2</span>][y_base][Z_BASE + <span class="number">1</span> + i] = c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">18</span>, <span class="number">0x100</span>):</span><br><span class="line">            board[x][y_base][Z_BASE + <span class="number">7</span>] = X_U_OP</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">0x100</span>):</span><br><span class="line">        board[<span class="number">0x100</span> - <span class="number">10</span>][y][Z_BASE + <span class="number">7</span>] = Y_D_OP</span><br><span class="line">    <span class="keyword">for</span> (i, c) <span class="keyword">in</span> <span class="built_in">enumerate</span>([NUM(<span class="number">1</span>), NUM(<span class="number">2</span>), SWAP_OP, STR_OP, NUM(<span class="number">16</span>), NUM(<span class="number">0</span>), STR_OP, SUB_OP, MUL_OP, ADD_OP]):</span><br><span class="line">        board[<span class="number">0x100</span> - <span class="number">10</span>][<span class="number">10</span> - i][Z_BASE + <span class="number">7</span>] = c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_board</span>():</span><br><span class="line">    board_list = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">        <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">            <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x100</span>):</span><br><span class="line">                <span class="keyword">if</span> board[x][y][z] != END_OP:</span><br><span class="line">                    b = <span class="built_in">ord</span>(board[x][y][z])</span><br><span class="line">                    board_list.append(<span class="string">f'(<span class="subst">{x}</span>, <span class="subst">{y}</span>, <span class="subst">{z}</span>) -&gt; <span class="subst">{b}</span>'</span>)</span><br><span class="line"></span><br><span class="line">    board_list.append(<span class="string">'END'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join(board_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">submit</span>():</span><br><span class="line">    c = remote(<span class="string">'202.38.93.111'</span>, <span class="number">10104</span>)</span><br><span class="line">    result = get_board()</span><br><span class="line">    c.recv()</span><br><span class="line">    c.sendline(TOKEN)</span><br><span class="line">    c.recv()</span><br><span class="line">    c.sendline(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(c.recvline())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    load_init()</span><br><span class="line">    load_command_dispatcher()</span><br><span class="line">    load_returner()</span><br><span class="line"></span><br><span class="line">    load_binocular_operator(<span class="string">'+'</span>, ADD_OP)</span><br><span class="line">    load_binocular_operator(<span class="string">'*'</span>, MUL_OP)</span><br><span class="line">    load_pow_operator()</span><br><span class="line">    load_shift_operator()</span><br><span class="line">    load_bitwise_operator(<span class="string">'|'</span>, <span class="keyword">lambda</span> x, y: x | y)</span><br><span class="line">    load_bitwise_operator(<span class="string">'x'</span>, <span class="keyword">lambda</span> x, y: x ^ y)</span><br><span class="line"></span><br><span class="line">    submit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure><h1 id="pq">p😭q</h1><p>这道题本质上就是<del>如何用眼看音乐</del>，是把频谱图转换为声波。</p><p>我本来以为这道题还要手撕 FFT 的，结果发现完全不用，首先给了代码，再者[见下文]，于是这道题就完全是一道工程题，只要会调库就可以了。</p><p>看源码，源码大致可以分成两个部分：正向 FFT，和 gif 生成。</p><p>我们就反过来“逆向”每一步就行了。</p><p>首先是读 gif，这个没啥好说的，只是细节比较多，直接上代码（趴）：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">'flag.gif'</span>)</span><br><span class="line"></span><br><span class="line">db_frames = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, gif_frame <span class="keyword">in</span> <span class="built_in">enumerate</span>(ImageSequence.Iterator(image)):</span><br><span class="line">    <span class="comment"># 将 gif_frame 转为 [x, y, 3] 的三维数组</span></span><br><span class="line">    frame = np.asarray(</span><br><span class="line">            gif_frame.convert(<span class="string">'RGB'</span>).getdata(),</span><br><span class="line">            dtype=np.uint8</span><br><span class="line">        ).reshape(gif_frame.size[<span class="number">1</span>], gif_frame.size[<span class="number">0</span>], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    dbs = []  <span class="comment"># 该 frame 中，频率对应的 dB</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, num_freqs):</span><br><span class="line">        <span class="keyword">for</span> i, threshold <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(min_db, max_db + <span class="number">1</span>, quantize))[::-<span class="number">1</span>], start=<span class="number">1</span>):</span><br><span class="line">            x = threshold - min_db</span><br><span class="line">            y = (freq * <span class="number">2</span> + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">            color = frame[x][y]</span><br><span class="line">            <span class="keyword">if</span> (color == white_pixel).<span class="built_in">all</span>():</span><br><span class="line">                dbs.append(i - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    db_frames.append(dbs)</span><br></pre></td></tr></tbody></table></figure><p>随后就是要逆向这个 <code>melspectrogram</code>。看源代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">spectrogram = (</span><br><span class="line">    numpy.around(</span><br><span class="line">        librosa.power_to_db(</span><br><span class="line">            librosa.feature.melspectrogram(</span><br><span class="line">                ...</span><br><span class="line">            )</span><br><span class="line">        ) / quantize</span><br><span class="line">    ) * quantize</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>最外层，<code>/ quantize</code>, <code>numpy.around</code>, <code>* quantize</code> 就是将 dB 取整。</p><p>然后再里面一层，就是 <code>librosa.power_to_db</code>，看这个命名……盲猜一下……大概有个函数……可以把它反过来，还真有：<code>librosa.db_to_power</code>。</p><p>再里面一层，就是 FFT 大头，<code>librosa.feature.melspectrogram</code>，本来呢，我还做好准备要手撕 FFT 的，然后一查文档，发现好家伙，这函数也有逆函数 <code>librosa.feature.inverse.mel_to_audio</code>，这就省事了。</p><p>接下来的事就是把上面的过程反过来套一遍就可以了：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db_frames = [ ... ]  <span class="comment"># 上面的 db_frames</span></span><br><span class="line"></span><br><span class="line">frames = np.array(db_frames).transpose(<span class="number">1</span>, <span class="number">0</span>)  <span class="comment"># 交换两维，我也不知道为啥要这样，反正接口要对上就对了</span></span><br><span class="line">frames += min_db</span><br><span class="line"><span class="comment"># 如果考虑上面的对 2 取整的话，实际上还要加上期望值 1 才对？</span></span><br><span class="line"></span><br><span class="line">y = librosa.feature.inverse.mel_to_audio(</span><br><span class="line">    librosa.db_to_power(frames),</span><br><span class="line">    <span class="number">22050</span>,  <span class="comment"># sample_rate</span></span><br><span class="line">    n_fft=fft_window_size,</span><br><span class="line">    hop_length=frame_step_size,</span><br><span class="line">    window=window_function_type</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sf.write(<span class="string">'origin.wav'</span>, y, <span class="number">22050</span>)</span><br></pre></td></tr></tbody></table></figure><p>至此，我们就把 gif 逆向成了 <code>origin.wav</code>。</p><p>音频是「The flag is, F-L-A-G, 634,971,243,582」（数字是英语数字的读法）。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是我个人的 write-up，仅包含我赛时会做的题（其它题看官方题解就好了，没必要再写一遍），记录自己做题时的奇奇怪怪的乱搞方法，仅供参考。&lt;/p&gt;
&lt;p&gt;由于我只是个菜鸡，所以解题方法可能会有点绕，&lt;del&gt;可能原理甚至有问题&lt;/del&gt;，请大佬原谅我这个菜鸡。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>浅谈 Minecraft 种子逆向</title>
    <link href="https://blog.monadx.com/2020/11/11/Minecraft-seed-cracking/"/>
    <id>https://blog.monadx.com/2020/11/11/Minecraft-seed-cracking/</id>
    <published>2020-11-11T06:00:00.000Z</published>
    <updated>2023-07-02T06:16:15.945Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章理论上应该在一年前写的，奈何一直咕咕咕，就拖到了现在。这几天有点时间，挤一挤把这玩意写一下。</p><p>之前在 MCBBS 上看到了这么一篇文章：<a href="https://www.mcbbs.net/thread-816891-1-1.html">地图种子逆向工程技巧：分区暴力搜索</a>（甚至现在还在首页），于是有感而发研究了一下。</p><span id="more"></span><blockquote><p>有感而发（✕），被激将了（✓）</p><p>真实情况：</p><p>由于文章里有这么一句话：<br>“<em>由于本文内容疑似涉及作弊，在此我不会给出与实际计算地图种子相关的代码，仅解释技术原理</em>”<br>我：我*，居然不给代码。你不让我实现，我偏要把它写出来，学 OI 的人最不缺的就是代码实现能力（大概吧）</p><p>而且那时也在玩服务器，刚好可以拿来开刀。</p></blockquote><h1 id="前置技能">前置技能</h1><ul><li>Java 代码阅读</li><li>Minecraft 代码逆向</li></ul><h1 id="how-to">How to</h1><p>一个非常显然的想法就是枚举所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个种子，然后每一个都跟地图比较一下。这样子理论上是可以的，但是实际上是不可行的。假设你每秒钟能生成出 1000 张地图（实际上可能更慢，参考 Minecraft 的地图生成速度），那么检测完所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个种子需要高达 6 亿年。</p><p>然后，<del>另一个自然的想法就是</del>，我们没必要精准比较，我们可以比较地图的特征。</p><p>Minecraft 地图有很多东西都是与种子有关的，比如最明显的生物群系、村庄、矿物之类的。通过这些不同的特征，我们可以逐个排除不可能的种子，最后剩下的就是符号条件的种子。并且，为了达到最高效率，枚举种子可以从容易实现（容易用代码复现）、运行快的特征开始，筛选排除不可能的种子，再用其它特征去判断。</p><p>也就是说，我们需要找到尽可能满足这些条件的算法：</p><ul><li><strong>运行快</strong>。比如说，生成生物群系需要迭代大约 45 层<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，每层都要做复杂的变换；相比之下，检查一个埋藏的宝藏就只需要测试一个随机数是否小于 <code>0.005</code> 即可。</li><li><strong>效率高</strong>。有的特征（例如埋藏的宝藏）的生成只与种子二进制位的低 48 位有关，这样我们就可以只遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个种子就可以了，效率高了不少。当然在这之后，对于高 16 位还要用其它算法来进行进一步筛选。</li><li>其它。比如这个算法是否好写（比如生成生物群系那个我就不想写）、这个特征在地图中是否容易收集（比如林地府邸就很难找，当然相对的这一个信息能排除掉的种子会更多）等。</li></ul><p>当然，实际中我们要结合几种算法综合使用，快速排除掉不符合的种子。</p><h2 id="scattered-feature">Scattered Feature</h2><p>Minecraft 常见的自然建筑，如女巫小屋、沙漠神殿等，都属于 Scattered Feature，它们的生成算法相同，只是参数有所改动。村庄的生成算法跟 Scattered Feature 相同，然而它在源码里不属于 Scattered Feature（虽然我也不知道为什么）。</p><p>Scattered Feature 的生成由三个参数控制：<code>Spacing</code>, <code>Separation</code>, <code>RandomSalt</code>。</p><p>在讲 Scattered Feature 的具体生成算法之前，先来说一下 Scattered Feature 的分布特征。</p><figure><a href="/images/2020-11-11-Minecraft-seed-cracking/scattered_feature_layout.png" class="glightbox"><img src="/images/2020-11-11-Minecraft-seed-cracking/scattered_feature_layout.png" alt="" loading="lazy"></a><figcaption>Scattered Feature Layout</figcaption></figure><p>如上图所示，地图中所有的区块被分成了若干个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>×</mo><mtext mathvariant="monospace">Spacing</mtext></mrow><annotation encoding="application/x-tex"> </annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span></span></span></span> 的正方形。每个正方形中，又只有左上角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( - ) ( - )</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mclose">)</span></span></span></span> 的部分可以生成建筑（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Separation</mtext></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span></span></span></span> 部分不生成建筑）。对于可以生成建筑的部分（绿色部分），会根据种子选择其中的一个区块，在其中尝试生成建筑。</p><p>具体这个区块是怎么选择的呢，我们来看一下代码（注：代码基于 Minecraft 1.14.4，代码为了可读性已作略微修改）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.minecraft.world.level.levelgen.feature.RandomScatteredFeature</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得区块 (chunk_x, chunk_z) 所在区域内的，可以尝试生成建筑的区块。</span></span><br><span class="line"><span class="keyword">protected</span> ChunkPos <span class="title function_">getPotentialFeatureChunkFromLocationWithOffset</span><span class="params">(ChunkGenerator&lt;?&gt; chunkGenerator, Random random, <span class="type">int</span> chunk_x, <span class="type">int</span> chunk_z)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">spacing</span> <span class="operator">=</span> <span class="built_in">this</span>.getSpacing(chunkGenerator);</span><br><span class="line">    <span class="type">int</span> <span class="variable">separation</span> <span class="operator">=</span> <span class="built_in">this</span>.getSeparation(chunkGenerator);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> chunk_x &lt; <span class="number">0</span> ? chunk_x - spacing + <span class="number">1</span> : chunk_x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> chunk_z &lt; <span class="number">0</span> ? chunk_z - spacing + <span class="number">1</span> : chunk_z;</span><br><span class="line">    x /= spacing;</span><br><span class="line">    y /= spacing;</span><br><span class="line">    ((WorldgenRandom)random).setLargeFeatureWithSalt(chunkGenerator.getSeed(), x, y, <span class="built_in">this</span>.getRandomSalt());</span><br><span class="line">    x *= spacing;</span><br><span class="line">    y *= spacing;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChunkPos</span>(x + random.nextInt(spacing - separation),</span><br><span class="line">                    y + random.nextInt(spacing - separation));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断区块 (chunk_x, chunk_z) 可不可以生成建筑（如果为 true 则一定会生成）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFeatureChunk</span><span class="params">(ChunkGenerator&lt;?&gt; chunkGenerator, Random random, <span class="type">int</span> chunk_x, <span class="type">int</span> chunk_z)</span> {</span><br><span class="line">    <span class="type">ChunkPos</span> <span class="variable">chunkPos</span> <span class="operator">=</span> <span class="built_in">this</span>.getPotentialFeatureChunkFromLocationWithOffset(chunkGenerator, random, chunk_x, chunk_z);</span><br><span class="line">    <span class="type">return</span> <span class="variable">chunk_x</span> <span class="operator">=</span>= chunkPos.x &amp;&amp; chunk_z == chunkPos.z <span class="comment">// Line A</span></span><br><span class="line">    &amp;&amp; chunkGenerator.isBiomeValidStartForStructure(chunkGenerator.getBiomeSource().getBiome(<span class="keyword">new</span> <span class="title class_">BlockPos</span>(chunk_x * <span class="number">16</span> + <span class="number">9</span>, <span class="number">0</span>, chunk_z * <span class="number">16</span> + <span class="number">9</span>)), <span class="built_in">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// net.minecraft.world.level.levelgen.WorldgenRandom</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setLargeFeatureWithSalt</span><span class="params">(<span class="type">long</span> world_seed, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> salt)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> (<span class="type">long</span>)x * <span class="number">341873128712L</span> + (<span class="type">long</span>)y * <span class="number">132897987541L</span> + world_seed + (<span class="type">long</span>)salt;</span><br><span class="line">    <span class="built_in">this</span>.setSeed(seed);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意到 <code>isFeatureChunk</code> 中有一个 <code>isBiomeValidStartForStructure</code>，这是用来判断这个区块的生物群系是否允许生成这个建筑（例如女巫小屋只能在沼泽生成）。因为生物群系的生成过于复杂，所以在实际实现中可以忽略检查生物群系，虽然会降低一点点效率，但是也不会意外排除合法的种子，权衡之下，这是可取的。</p><p>剩下的事就是模拟一下这个生成算法就可以枚举种子了。</p><h3 id="优化">优化</h3><p>虽然说 <code>Random</code> 只用到了种子的低 48 位<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，但是枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个种子还是有点困难。</p><p>根据上面那篇文章<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>所说，<code>Random.nextInt(24) % 8</code> 取随机数时，所得的结果只与种子的低 20 位有关。这样我们只需要找符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex"> -  = 24</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 的建筑（比如村庄），用这个方法加速破解即刻。</p><p>关于这个结论的证明，可以在“USTC Hackergame 2020 超迷你的挖矿模拟器”的题解<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>中找到。并且根据这篇题解所说，这个结论可以扩展至 <code>Random.nextInt() % 16</code> 取随机数时，所得的结果只与种子的低 20 位有关。这样的话，只要是符合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>16</mn></mrow><annotation encoding="application/x-tex"> -  0 16</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 的建筑即刻。如果是村庄（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex"> -  = 24</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span>），我们可以把模数下放至 8，这样一样可以加速（当然会有一点效率损失，但是可以忽略不计）。</p><p>用这个方法把低 20 位挖出来之后，再用上面的方法把低 21~48 位筛出来即可。</p><h2 id="生物群系">生物群系</h2><p>要获取种子的高 16 位，比较好的方法就是用生物群系。<del>但是生物群系生成那么复杂，手写是不可能手写的</del>，于是我就找到了（<del>白嫖</del>）一个现成的库：<a href="https://github.com/Cubitect/cubiomes">cubiome</a>。</p><p>把这个库魔改一下，枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 个种子，检查生物群系是不是符合现有的地图即可。</p><div class="tip"><p>值得注意的是，Minecraft 的生物群系是精确到一个方块（平面上的一个方块）的，而不是像 Chunkbase 显示的一个区块。</p></div><h1 id="代码">代码</h1><p><del>我知道你们都想白嫖代码</del></p><p>这里写了一个 Minecraft 1.13.2 查找种子的程序，<a href="https://github.com/YanWQ-monad/MinecraftSeedReverse">MinecraftSeedReverse</a>（查找高 16 位调用了 cubiomes）。</p><p>虽然说 1.14 跟 1.15 的也有，但是我改用了 Rust 编写（筛选低 48 位的部分），但是查找高 16 位还要另外写程序用 C++ 跑 cubiomes，有点不美观，就一直没有放上来。</p><p>如果要一站式的开箱即用的工具，有位外国小哥开发了一个 mod，叫做 <a href="https://github.com/KaptainWutax/SeedCracker">SeedCracker</a>，可以自动搜集信息自动破解，而且搜集的信息比我上面写的还多（虽然它没有用生物群系）。比我手动的智能多了。</p><h1 id="参考">参考</h1><section class="footnotes" role="doc-endnotes"><ol><li id="fn1" role="doc-endnote"><p><a href="https://github.com/Cubitect/cubiomes/blob/master/LayerSummary.pdf">Cubitect. <em>Summary of the Biome Generation in Minecraft 1.7 - 1.12</em></a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p><a href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Random.java#l146">Source of <code>java.util.Random</code></a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p><a href="https://www.mcbbs.net/thread-816891-1-1.html">地图种子逆向工程技巧：分区暴力搜索</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4" role="doc-endnote"><p><a href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/超迷你的挖矿模拟器/README.md">USTC Hackergame 2020 超迷你的挖矿模拟器 题解</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章理论上应该在一年前写的，奈何一直咕咕咕，就拖到了现在。这几天有点时间，挤一挤把这玩意写一下。&lt;/p&gt;
&lt;p&gt;之前在 MCBBS 上看到了这么一篇文章：&lt;a href=&quot;https://www.mcbbs.net/thread-816891-1-1.html&quot;&gt;地图种子逆向工程技巧：分区暴力搜索&lt;/a&gt;（甚至现在还在首页），于是有感而发研究了一下。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>迁移到 Hexo</title>
    <link href="https://blog.monadx.com/2019/07/20/Migrate-to-Hexo/"/>
    <id>https://blog.monadx.com/2019/07/20/Migrate-to-Hexo/</id>
    <published>2019-07-20T16:00:00.000Z</published>
    <updated>2023-07-02T06:16:15.945Z</updated>
    
    <content type="html"><![CDATA[<p>其实很早就入坑 GitHub Pages 写博客了，之前一直在用 <a href="https://github.com/Huxpro/huxblog-boilerplate">HuxBlog</a> 模板。其实它还是挺不错的，只是有些细节我不太满意。另观 Hexo 也挺不错的，特别是发现了这个简洁又美观的主题之后，就决定迁过来。</p><span id="more"></span><p>一开始用的时候感觉还是挺好的，只是由于 jekyll 的可定制性低（GitHub 不允许运行 jekyll 插件），各种修改都只能交给前端 JavaScript 来完成（比如<a href="https://github.com/YanWQ-monad/YanWQ-monad.github.io-archive/blob/blog/_includes/footer.html#L144-L291">这一段</a>）。每次都是随便地加一点，改一点，久而久之就会变得难以维护。虽然说后来也换成了 Travis CI 来构建，但是也懒得写 jekyll 插件了（懒得学 Ruby）。</p><p>其次就是<del>我感觉</del> HuxBlog 还是挺重的，依赖 jQuery，Bootstrap 等库。特别点名 jQuery，只用了它 1% 的功能却要消耗几十 KB 的流量。这点流量平时可能不算什么，可是当它放到 GitHub Pages 上加载，速度就会变得其慢无比，这是我无法忍受的。还有就是主页上那张 203 KB 的图，加载要 8s。各种因素综合起来导致旧博客的 DOMContentLoaded 需要 5s，Load 需要 12s（本地测试结果），无论是谁都受不了这个速度。（<del>其实说白了就是我懒得优化</del>）</p><p>第三个原因就是它的样式我不太喜欢。一开始用的时候没有什么感觉，但是当用久了，感觉 HuxBlog 的冷色调有点偏重。期间也逛了一下 <a href="https://oi.men.ci">Menci</a> 等人的博客，发现令人赏心悦目的博客都是基于暖色调的，<del>充满了 OI 的人情味</del>。</p><p>如果说还有一点，就是 jekyll 的本地构建太麻烦了，这对一个框架的体验有很大关系。每次都要装一个<del>硕大的</del> Ruby，然后又要装一堆 jekyll 的依赖，而且 jekyll 构建的速度又非常感人（指在 Windows 上），如果开 Incremental Regeneration 又不一定能正确渲染，体验不是很佳。（<del>好像说得 Hexo 和 npm 就没有一大堆依赖一样</del>，逃）</p><p>由于这三个原因，我就把旧的博客扔在一边没有去管，<del>这就是我不更新博客的理由吗？</del></p><p>后来不知道从哪发现的 <a href="https://blog.phoenixlzx.com">Phoenix's blog</a>，这个主题（<a href="https://github.com/pinggod/hexo-theme-apollo">apollo</a>）让我眼前一亮，看上去非常简洁、清新，而且它只有一个 4KB 的 CSS，不依赖任何第三方库。于是就临时起意，大手一挥（大误），把博客迁移到 Hexo 来。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;其实很早就入坑 GitHub Pages 写博客了，之前一直在用 &lt;a href=&quot;https://github.com/Huxpro/huxblog-boilerplate&quot;&gt;HuxBlog&lt;/a&gt; 模板。其实它还是挺不错的，只是有些细节我不太满意。另观 Hexo 也挺不错的，特别是发现了这个简洁又美观的主题之后，就决定迁过来。&lt;/p&gt;</summary>
    
    
    
    <category term="日常" scheme="https://blog.monadx.com/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
  </entry>
  
</feed>
