<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 浅谈 Minecraft 种子逆向 · Monad's Blog</title><meta name="description" content="浅谈 Minecraft 种子逆向 - Monad"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/images/favicon.png"><link rel="preload" href="/css/apollo.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/apollo.css"></noscript><link rel="preload" href="/katexify/katex.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/katexify/katex.min.css"></noscript><link rel="preload" href="/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/all.min.css"></noscript><link rel="search" type="application/opensearchdescription+xml" href="https://blog.monadx.com/atom.xml" title="Monad's Blog"><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="Monad's Blog" type="application/atom+xml">
</head><body><noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PP344KH" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript><div class="wrap"><header><a class="logo-link" href="/"><img src="/images/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/YanWQ-monad" target="_blank" rel="noopener">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/about" target="_self">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block" itemscope itemtype="http://schema.org/Article"><h1 class="post-title" itemprop="name">浅谈 Minecraft 种子逆向</h1><div class="hidden" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Monad</span></div><div class="hidden" itemprop="dateModified" content="2023-07-02">2023年7月2日</div><div class="post-info" itemprop="datePublished" content="2020-11-11">2020年11月11日</div><div class="post-content" itemprop="articleBody"><p>这篇文章理论上应该在一年前写的，奈何一直咕咕咕，就拖到了现在。这几天有点时间，挤一挤把这玩意写一下。</p>
<p>之前在 MCBBS 上看到了这么一篇文章：<a target="_blank" rel="noopener" href="https://www.mcbbs.net/thread-816891-1-1.html">地图种子逆向工程技巧：分区暴力搜索</a>（甚至现在还在首页），于是有感而发研究了一下。</p>
<span id="more"></span>
<blockquote>
<p>有感而发（✕），被激将了（✓）</p>
<p>真实情况：</p>
<p>由于文章里有这么一句话：<br>
“<em>由于本文内容疑似涉及作弊，在此我不会给出与实际计算地图种子相关的代码，仅解释技术原理</em>”<br>
我：我*，居然不给代码。你不让我实现，我偏要把它写出来，学 OI 的人最不缺的就是代码实现能力（大概吧）</p>
<p>而且那时也在玩服务器，刚好可以拿来开刀。</p>
</blockquote>
<h1 id="前置技能">前置技能</h1>
<ul>
<li>Java 代码阅读</li>
<li>Minecraft 代码逆向</li>
</ul>
<h1 id="how-to">How to</h1>
<p>一个非常显然的想法就是枚举所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个种子，然后每一个都跟地图比较一下。这样子理论上是可以的，但是实际上是不可行的。假设你每秒钟能生成出 1000 张地图（实际上可能更慢，参考 Minecraft 的地图生成速度），那么检测完所有的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow><annotation encoding="application/x-tex">2^{64}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">4</span></span></span></span></span></span></span></span></span></span></span></span> 个种子需要高达 6 亿年。</p>
<p>然后，<del>另一个自然的想法就是</del>，我们没必要精准比较，我们可以比较地图的特征。</p>
<p>Minecraft 地图有很多东西都是与种子有关的，比如最明显的生物群系、村庄、矿物之类的。通过这些不同的特征，我们可以逐个排除不可能的种子，最后剩下的就是符号条件的种子。并且，为了达到最高效率，枚举种子可以从容易实现（容易用代码复现）、运行快的特征开始，筛选排除不可能的种子，再用其它特征去判断。</p>
<p>也就是说，我们需要找到尽可能满足这些条件的算法：</p>
<ul>
<li><strong>运行快</strong>。比如说，生成生物群系需要迭代大约 45 层<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，每层都要做复杂的变换；相比之下，检查一个埋藏的宝藏就只需要测试一个随机数是否小于 <code>0.005</code> 即可。</li>
<li><strong>效率高</strong>。有的特征（例如埋藏的宝藏）的生成只与种子二进制位的低 48 位有关，这样我们就可以只遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个种子就可以了，效率高了不少。当然在这之后，对于高 16 位还要用其它算法来进行进一步筛选。</li>
<li>其它。比如这个算法是否好写（比如生成生物群系那个我就不想写）、这个特征在地图中是否容易收集（比如林地府邸就很难找，当然相对的这一个信息能排除掉的种子会更多）等。</li>
</ul>
<p>当然，实际中我们要结合几种算法综合使用，快速排除掉不符合的种子。</p>
<h2 id="scattered-feature">Scattered Feature</h2>
<p>Minecraft 常见的自然建筑，如女巫小屋、沙漠神殿等，都属于 Scattered Feature，它们的生成算法相同，只是参数有所改动。村庄的生成算法跟 Scattered Feature 相同，然而它在源码里不属于 Scattered Feature（虽然我也不知道为什么）。</p>
<p>Scattered Feature 的生成由三个参数控制：<code>Spacing</code>, <code>Separation</code>, <code>RandomSalt</code>。</p>
<p>在讲 Scattered Feature 的具体生成算法之前，先来说一下 Scattered Feature 的分布特征。</p>
<figure>
<a href="/images/2020-11-11-Minecraft-seed-cracking/scattered_feature_layout.png" class="glightbox"><img src="/images/2020-11-11-Minecraft-seed-cracking/scattered_feature_layout.png" alt="" loading="lazy"></a><figcaption>Scattered Feature Layout</figcaption>
</figure>
<p>如上图所示，地图中所有的区块被分成了若干个大小为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>×</mo><mtext mathvariant="monospace">Spacing</mtext></mrow><annotation encoding="application/x-tex"> </annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span></span></span></span> 的正方形。每个正方形中，又只有左上角 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">( - ) ( - )</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mclose">)</span></span></span></span> 的部分可以生成建筑（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Separation</mtext></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span></span></span></span> 部分不生成建筑）。对于可以生成建筑的部分（绿色部分），会根据种子选择其中的一个区块，在其中尝试生成建筑。</p>
<p>具体这个区块是怎么选择的呢，我们来看一下代码（注：代码基于 Minecraft 1.14.4，代码为了可读性已作略微修改）：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net.minecraft.world.level.levelgen.feature.RandomScatteredFeature</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得区块 (chunk_x, chunk_z) 所在区域内的，可以尝试生成建筑的区块。</span></span><br><span class="line"><span class="keyword">protected</span> ChunkPos <span class="title function_">getPotentialFeatureChunkFromLocationWithOffset</span><span class="params">(ChunkGenerator&lt;?&gt; chunkGenerator, Random random, <span class="type">int</span> chunk_x, <span class="type">int</span> chunk_z)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">spacing</span> <span class="operator">=</span> <span class="built_in">this</span>.getSpacing(chunkGenerator);</span><br><span class="line">    <span class="type">int</span> <span class="variable">separation</span> <span class="operator">=</span> <span class="built_in">this</span>.getSeparation(chunkGenerator);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> chunk_x &lt; <span class="number">0</span> ? chunk_x - spacing + <span class="number">1</span> : chunk_x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> chunk_z &lt; <span class="number">0</span> ? chunk_z - spacing + <span class="number">1</span> : chunk_z;</span><br><span class="line">    x /= spacing;</span><br><span class="line">    y /= spacing;</span><br><span class="line">    ((WorldgenRandom)random).setLargeFeatureWithSalt(chunkGenerator.getSeed(), x, y, <span class="built_in">this</span>.getRandomSalt());</span><br><span class="line">    x *= spacing;</span><br><span class="line">    y *= spacing;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ChunkPos</span>(x + random.nextInt(spacing - separation),</span><br><span class="line">    	                y + random.nextInt(spacing - separation));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断区块 (chunk_x, chunk_z) 可不可以生成建筑（如果为 true 则一定会生成）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFeatureChunk</span><span class="params">(ChunkGenerator&lt;?&gt; chunkGenerator, Random random, <span class="type">int</span> chunk_x, <span class="type">int</span> chunk_z)</span> {</span><br><span class="line">    <span class="type">ChunkPos</span> <span class="variable">chunkPos</span> <span class="operator">=</span> <span class="built_in">this</span>.getPotentialFeatureChunkFromLocationWithOffset(chunkGenerator, random, chunk_x, chunk_z);</span><br><span class="line">    <span class="type">return</span> <span class="variable">chunk_x</span> <span class="operator">=</span>= chunkPos.x &amp;&amp; chunk_z == chunkPos.z <span class="comment">// Line A</span></span><br><span class="line">    	&amp;&amp; chunkGenerator.isBiomeValidStartForStructure(chunkGenerator.getBiomeSource().getBiome(<span class="keyword">new</span> <span class="title class_">BlockPos</span>(chunk_x * <span class="number">16</span> + <span class="number">9</span>, <span class="number">0</span>, chunk_z * <span class="number">16</span> + <span class="number">9</span>)), <span class="built_in">this</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// net.minecraft.world.level.levelgen.WorldgenRandom</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setLargeFeatureWithSalt</span><span class="params">(<span class="type">long</span> world_seed, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> salt)</span> {</span><br><span class="line">    <span class="type">long</span> <span class="variable">seed</span> <span class="operator">=</span> (<span class="type">long</span>)x * <span class="number">341873128712L</span> + (<span class="type">long</span>)y * <span class="number">132897987541L</span> + world_seed + (<span class="type">long</span>)salt;</span><br><span class="line">    <span class="built_in">this</span>.setSeed(seed);</span><br><span class="line">    <span class="keyword">return</span> seed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>注意到 <code>isFeatureChunk</code> 中有一个 <code>isBiomeValidStartForStructure</code>，这是用来判断这个区块的生物群系是否允许生成这个建筑（例如女巫小屋只能在沼泽生成）。因为生物群系的生成过于复杂，所以在实际实现中可以忽略检查生物群系，虽然会降低一点点效率，但是也不会意外排除合法的种子，权衡之下，这是可取的。</p>
<p>剩下的事就是模拟一下这个生成算法就可以枚举种子了。</p>
<h3 id="优化">优化</h3>
<p>虽然说 <code>Random</code> 只用到了种子的低 48 位<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，但是枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span> 个种子还是有点困难。</p>
<p>根据上面那篇文章<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>所说，<code>Random.nextInt(24) % 8</code> 取随机数时，所得的结果只与种子的低 20 位有关。这样我们只需要找符号 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex"> -  = 24</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span> 的建筑（比如村庄），用这个方法加速破解即刻。</p>
<p>关于这个结论的证明，可以在“USTC Hackergame 2020 超迷你的挖矿模拟器”的题解<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>中找到。并且根据这篇题解所说，这个结论可以扩展至 <code>Random.nextInt() % 16</code> 取随机数时，所得的结果只与种子的低 20 位有关。这样的话，只要是符合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="0.6666666666666666em"></mspace><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mtext> </mtext><mtext> </mtext><mn>16</mn></mrow><annotation encoding="application/x-tex"> -  0 16</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:0.6666666666666666em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord"><span class="mord mathrm">m</span><span class="mord mathrm">o</span><span class="mord mathrm">d</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">6</span></span></span></span> 的建筑即刻。如果是村庄（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Spacing</mtext><mo>−</mo><mtext mathvariant="monospace">Separation</mtext><mo>=</mo><mn>24</mn></mrow><annotation encoding="application/x-tex"> -  = 24</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Spacing</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.22222em;"></span><span class="mord text"><span class="mord texttt">Separation</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span></span></span></span>），我们可以把模数下放至 8，这样一样可以加速（当然会有一点效率损失，但是可以忽略不计）。</p>
<p>用这个方法把低 20 位挖出来之后，再用上面的方法把低 21~48 位筛出来即可。</p>
<h2 id="生物群系">生物群系</h2>
<p>要获取种子的高 16 位，比较好的方法就是用生物群系。<del>但是生物群系生成那么复杂，手写是不可能手写的</del>，于是我就找到了（<del>白嫖</del>）一个现成的库：<a target="_blank" rel="noopener" href="https://github.com/Cubitect/cubiomes">cubiome</a>。</p>
<p>把这个库魔改一下，枚举 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" data-aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span> 个种子，检查生物群系是不是符合现有的地图即可。</p>
<div class="tip">
<p>值得注意的是，Minecraft 的生物群系是精确到一个方块（平面上的一个方块）的，而不是像 Chunkbase 显示的一个区块。</p>
</div>
<h1 id="代码">代码</h1>
<p><del>我知道你们都想白嫖代码</del></p>
<p>这里写了一个 Minecraft 1.13.2 查找种子的程序，<a target="_blank" rel="noopener" href="https://github.com/YanWQ-monad/MinecraftSeedReverse">MinecraftSeedReverse</a>（查找高 16 位调用了 cubiomes）。</p>
<p>虽然说 1.14 跟 1.15 的也有，但是我改用了 Rust 编写（筛选低 48 位的部分），但是查找高 16 位还要另外写程序用 C++ 跑 cubiomes，有点不美观，就一直没有放上来。</p>
<p>如果要一站式的开箱即用的工具，有位外国小哥开发了一个 mod，叫做 <a target="_blank" rel="noopener" href="https://github.com/KaptainWutax/SeedCracker">SeedCracker</a>，可以自动搜集信息自动破解，而且搜集的信息比我上面写的还多（虽然它没有用生物群系）。比我手动的智能多了。</p>
<h1 id="参考">参考</h1>
<section class="footnotes" role="doc-endnotes">

<ol>
<li id="fn1" role="doc-endnote"><p><a target="_blank" rel="noopener" href="https://github.com/Cubitect/cubiomes/blob/master/LayerSummary.pdf">Cubitect. <em>Summary of the Biome Generation in Minecraft 1.7 - 1.12</em></a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a target="_blank" rel="noopener" href="https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/tip/src/share/classes/java/util/Random.java#l146">Source of <code>java.util.Random</code></a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a target="_blank" rel="noopener" href="https://www.mcbbs.net/thread-816891-1-1.html">地图种子逆向工程技巧：分区暴力搜索</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a target="_blank" rel="noopener" href="https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/超迷你的挖矿模拟器/README.md">USTC Hackergame 2020 超迷你的挖矿模拟器 题解</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2021/10/31/Hackergame-2021/">PREV</a><a class="next" href="/2019/07/20/Migrate-to-Hexo/">NEXT</a></div><div class="copyright"><p>© 2017 - 2023 <a href="https://blog.monadx.com">Monad</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.defer=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer',"GTM-PP344KH");</script><script src="/js/all.min.js" defer></script></body></html>