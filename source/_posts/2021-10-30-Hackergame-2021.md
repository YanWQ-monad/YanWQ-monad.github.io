---
title: Hackergame 2021 个人 Writeup
permalinks: Hackergame-2021
date: 2021-10-31 10:00:00
---

这是我个人的 write up，仅包含我赛时会做的题（其它题看官方题解就好了，没必要再写一遍），记录自己做题时的奇奇怪怪的乱搞方法，仅供参考。

由于我只是个菜鸡，所以解题方法可能会有点绕，~~可能原理甚至有问题~~，请大佬原谅我这个菜鸡。

<!-- more -->

> **Work In Progress**

# 前言

> 此部分暂咕

# 目录

注：打了 ❌ 的都是不会做的，没有链接的都是待更新的。

- [签到](#签到)
- [进制十六——参上](#进制十六参上)
- [去吧！追寻自由的电波](#去吧追寻自由的电波)
- [猫咪问答 Pro Max](#猫咪问答-pro-max)
- 卖瓜
- [透明的文件](#透明的文件)
- [旅行照片](#旅行照片)
- [FLAG 助力大红包](#flag-助力大红包)
- Amnesia
  * [轻度失忆](#amnesia---轻度失忆)
  * 记忆清除 ❌
- [图之上的信息](#图之上的信息)
- [Easy RSA](#easy-rsa)
- [加密的 U 盘](#加密的-u-盘)
- 赛博厨房
  * [Level 0](#level-0)
  * [Level 1](#level-1)
  * [Level 2](#level-2)
  * Level 3 ❌
- 灯，等灯等灯
  * [Level 0](#level-0-1)
  * Level 1 ❌
  * Level 2 ❌
- 只读文件系统 ❌
- 一石二鸟 ❌
- [Micro World](#micro-world)
- 卷王与野生的 GPA ❌
- 阵列恢复大师
  * 1 - RAID 0
  * 2 - RAID 5
- 链上预言家 ❌
- [助记词](#助记词)
  * [第一顿大餐](#第一顿大餐)
  * [第二顿大餐](#第二顿大餐)
- Co-Program ❌
- 马赛克
- minecRaft
- [密码生成器](#密码生成器)
- 外星人的音游掌机 ❌
- JUST BE FUN
- fzuu ❌
- p😭q
- Make a wish ❌
- 超 OI 的 Writeup 模拟器 ❌


# 签到
点按钮可以切换 Page，然后不同的 Page 对应不同时间。  
并且可以观察到，Page 的 number 就是 Unix 时间戳。  
~~我们不妨大胆猜想~~，把 Unix 时间戳设置成当前时间，即访问 `http://202.38.93.111:10000/?page=1634968833`，然后发现就可以获得 Flag。


# 进制十六——参上
观察到右边的 flag 被遮住了，但是左边的 hex 却没有被遮住。所以就可以解析左边的 hex 得到右边的 flag：

```python
codecs.decode(
    '666c61677b5930555f5348305531445f6b6e30775f4830575f74305f43306e763372745f4845585f746f5f546578547d',
    'hex')
```

# 去吧！追寻自由的电波
下载音频，发现音频播放速度非常快，大概是被暴力压缩了。  
我们可以随便找点软件，把音频放慢，就可以听了。

题目云「使用了无线电中惯用的方法来区分字符串中读音相近的字母」，即 `e` 用 `echo` 表示，等。
虽然英语听力不太行，但是听首字母还是能勉强听得出来的。

> 小彩蛋(?)：把音频放的没那么慢，可以听到女声；再放慢点，就变成了男声，这就说明……（逃）

# 猫咪问答 Pro Max

> 1. 2017 年，中科大信息安全俱乐部（SEC@USTC）并入中科大 Linux 用户协会（USTCLUG）。目前，信息安全俱乐部的域名（sec.ustc.edu.cn）已经无法访问，但你能找到信息安全俱乐部的社团章程在哪一天的会员代表大会上通过的吗？  
>    提示：输入格式为 YYYYMMDD，如 20211023。请不要回答 “能” 或者 “不能”。

看到「已经无法访问」，直接下意识想到 [web.archive.org](https://web.archive.org)。

在 web archive 里打开 `sec.ustc.edu.cn`，找到章程，然后就找到其通过日期为 2015 年 5 月 4 日。

> 2. 中国科学技术大学 Linux 用户协会在近五年多少次被评为校五星级社团？  
>    提示：是一个非负整数。

查资料无果（可能我姿势不对），先下一题。

> 3. 中国科学技术大学 Linux 用户协会位于西区图书馆的活动室门口的牌子上“LUG @ USTC”下方的小字是？  
>    提示：正确答案的长度为 27，注意大小写。

~~经过多次搜索尝试~~，在 Google 搜索 “LUG USTC” 并切换至“图片”一栏，就可以发现这么一张照片：

![](LUG_USTC_Lab.png)

即 “Development Team of Library”，刚好是 27 个字。

> 4. 在 SIGBOVIK 2021 的一篇关于二进制 Newcomb-Benford 定律的论文中，作者一共展示了多少个数据集对其理论结果进行验证？  
>    提示：是一个非负整数。

搜索 “SIGBOVIK Newcomb-Benford”，然后就能找到一篇论文（集）：[SIGBOVIK 2021](http://sigbovik.org/2021/proceedings.pdf)。

通过目录找到这篇文章，~~然后仔细阅读，并且与作者友善探讨学术问题（大雾）。~~  

实际上通过~~简单~~提取，不难发现附录的 figures 都是数据集，一共有 14 - 1 = 13 个

> 5. 不严格遵循协议规范的操作着实令人生厌，好在 IETF 于 2021 年成立了 Protocol Police 以监督并惩戒所有违背 RFC 文档的行为个体。假如你发现了某位同学可能违反了协议规范，根据 Protocol Police 相关文档中规定的举报方法，你应该将你的举报信发往何处？  
>    正确答案的长度为 9。

搜索 “IETF Protocol Police”，不难找到 [RFC 8962](https://datatracker.ietf.org/doc/html/rfc8962)。

直接搜索关键词 `(e)mail` 或 `send`，不难找到「Send all your reports of possible violations and all tips about wrongdoing to **/dev/null**.」。

所以答案就是 `/dev/null`，长度也刚好是 9。

（手动分割线）

然后至此我们找到了 1, 3, 4, 5 的答案，还剩下的第 2 题，可能的答案只有 6 种，手动枚举一下即可（~~居然是 5 次，我还以为是 0~~）。

# 卖瓜

说实话，我猜不出它（服务器 PHP 代码）是怎么算的，然后就搞不清楚具体是怎么溢出的，~~但是还是可以瞎试~~。

~~完了，我忘记我当时是怎么试的了。~~

# 透明的文件
打开文件，发现里面的字符好像 `\033` 控制符（然后就是缺了 `\033`）。不妨试试在 `[` 前都加上 `\033`（据说 `\033` 后面一定会接着 `[`）。

然后打印之，可得：

![](transparent_console.png)

~~不难读出~~，flag 是 `flag{abxnniohkalmcowsayfiglet}`。

# 旅行照片

读题，发现题目的着重点在 KFC 上，并且其非常近海，猜想符合条件的 KFC 不多。  
于是搜索 “海边 KFC”，虽然不能直接找到目标（大概?），但是过半的搜索结果都是关于“秦皇岛”的。  
然后打开地图，定位到秦皇岛，查找附近的 KFC，得：

![](Qinhuangdao_KFC.png)

发现有一家 KFC 很接近海，打开卫星图模式，并放大观察：

![](Qinhuangdao_KFC_satellite.png)

可以发现停车位对上了，那块覆盖着植被的石头也对上了，~~虽然 KFC 位置出现了一点偏差，但是不影响做题~~。

观察原图的停车位方向和阴影方向，不难发现拍摄者面朝**东南**，时间是**傍晚**。

然后打开百度街景（不是广告），观察实地景象。~~百度街景这都多久没更新了？~~  

![](Qinhuangdao_dolphinarium.png)

~~虽然没有 KFC~~，但观察屋顶，还是能确定就是那里的。然后就能确定那三个大字就是「**海豚馆**」。

然后打开 [KFC 门店信息查询](https://www.kfc.com.cn/kfccda/storelist/index.aspx)，定位秦皇岛。  
虽然「新澳海底世界甜品餐厅」没有电话，猜测电话跟旁边的「新澳海底世界餐厅餐厅」一样（**0335-7168800**）。

最后还剩下楼层高度，看隔壁楼层数一下，大概是在 **14** 层左右（如果不对就上下多试几层就对了）。

# FLAG 助力大红包
总结题意：你需要用 256 个不同的 /8 IP 地址砍红包（访问对应 URL）。

但是这怎么可能呢，有些 IP 段本来就是有保留用途的，而且时间还限制 10 分钟。

~~经过一番胡思乱想~~，发现可以通过携带 `X-Forwarded-For` header 来欺骗，就能轻松砍到 flag。

# Amnesia - 轻度失忆

`.data` 段没了，字符串常量是储存在这里的。既然不能用字符串常量，就分割成字符就可以了。

```c
#include <stdio.h>

int main() {
    putchar('H');
    putchar('e');
    putchar('l');
    putchar('l');
    putchar('o');
    putchar(',');
    putchar(' ');
    putchar('w');
    putchar('o');
    putchar('r');
    putchar('l');
    putchar('d');
    putchar('!');

    return 0;
}
```

# 图之上的信息

经过简单尝试，可以知道 GraphQL 里面有 `GUser` 类型，其中有 `id`, `username` 两个字段。

查文档，找到“内省”部分，可以用如下代码获取 `GUser` 的所有字段：

```graphql
{ "query": "{ __type(name: \"GUser\") { name, fields { name }}}"}
```

得到其所有字段：`id`, `username`, `privateEmail`。

再查询 `id` 为 1 的 admin 用户的 `privateEmail` 即可：

```graphql
{ "query": "{ user(id: 1) { id, username, privateEmail }}" }
```

# Easy RSA

观察代码，我们有三个任务：

1. 计算 `p`
2. 通过 `value[-1]` 反推全部 `value`
3. 通过 `value_q` 反推 `q`

## 1. 计算 `p`

查找资料，可以找到一个叫“威尔逊定理”的东西，即当 `p` 为质数的时候：

$$
(p - 2)! \equiv 1 \enspace (\operatorname{mod} p)
$$

则：

$$
y! \equiv (x - 2)! \times \frac{y!}{(x - 2)!} \equiv \frac{1}{\prod_{i = y + 1}^{x - 2} i} \equiv \prod_{i = y + 1}^{x - 2} inv(i) \quad (\operatorname{mod} x)
$$

代码：

```python
def get_p(x, y):
    mul = 1
    for i in range(y + 1, x - 2 + 1):
        mul = mul * inv(i, x, x - 2) % x
    return mul
```

## 2. 反推 `value`

这个部分涉及到一个最主要的函数就是 `sympy.nextprime`，先看看它的文档：

> `def nextprime(n, ith = 1)`  
> Return the ith prime greater than n.  
> See Also: prevprime: Return the largest prime smaller than n.

……我感觉官方文档都告诉你应该怎么做了。

```python
def get_first_value(last_value):
    val = last_value
    for _ in range(9):
        val = sympy.prevprime(val)
    return val
```

## 3. 反推原始 `q`

这个部分就是给出这个式子（我们把这个原始的 `q` 称为 `x`）：

$$
q \equiv x^e \enspace (\operatorname{mod} n)
$$

已知 `e`, `n`, `q`，求 `x`。

~~然后我不会求~~，查资料，发现了这个：[Finding the k-th root modulo m](https://math.stackexchange.com/questions/2073284/finding-the-kth-root-modulo-m)，简直完美。

按照这篇文章（回答）所说，首先求满足这一式子的 $k$, $v$：

$$
u \, e - v \, \varphi(n) = 1
$$

显然 $\gcd(e, \, \varphi(n)) = 1$，这一步可以用 exgcd 做。

求出来了之后，就有

$$
x \equiv (b^u)^e \enspace (\operatorname{mod} n)
$$

写成代码，就是：

```python
# 这里的 n 我们通过 `first_value` 生成
def get_original_q(e, q, first_value):
    value = [ first_value ]
    for i in range(1, 10):
        value.append(sympy.nextprime(value[i - 1]))

    # 这样求 phi 可以快不少，该函数要求 factors 中的 keys 都是质数。
    factors = { v: 1 for v in value }
    pn = sympy.ntheory.factor_.totient._from_factors(factors)

    # Ex-GCD, 其中 h = gcd(e, pn)，u, v 含义如上所述
    (u, v, h) = sympy.polys.polytools.gcdex(e, pn)

    x = pow(pow(q, int(u), n), e, n)
    return x
```

经过验证，以上三个脚本都可以算出的结果，代入进源程序中，都可以算出源码中对应的结果。

## 4. RSA 解密

RSA 解密还需要一个数 $d$（含义请自行翻看 RSA 文档，也可以看[这篇](https://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)）。

算 $d$ 满足以下式子：

$$
ed \equiv 1 \enspace (\operatorname{mod} n)
$$

在先进的 `Python 3.8+` 中，可以直接用 `pow(x, -1, mod)` 来算逆元，省事不少。

于是解密部分的代码：

```python
pn = sympy.ntheory.factor_.totient._from_factors({ p: 1, q: 1 })  # phi(n)

d = pow(e, -1, pn)

c = 110644875422336073...
m = pow(c, d, p * q)
print(m)
print(m.to_bytes(32, "big"))
```

然后就可以拿到 flag 了。

# 加密的 U 盘

通过查询 LUKS 的使用文档，可以发现其可以使用密码或 keyfile 加密，于是大胆猜测改密码不会改变 keyfile 一类的东西（注：实际上是 master key 不会变）。

首先使用 `losetup -P /dev/loop1 day1.img` 将镜像挂载至 loopback（day2 同理）。

然后用 `cryptsetup luksDump --dump-master-key /dev/loop1p1` dump 出 master key。`MK dump` 里就是 master key。并用 `xxd` 或其它工具将 master key 写入文件。

接着用 master key 打开 `day2.img` 即可：`sudo cryptsetup luksOpen --master-key-file <key file> /dev/loop2p1 day2`。

最后把 `/dev/mapper/day2` mount 一下就能读出 `flag.txt` 了。


# 赛博厨房

## Level 0

写 4 个程序，针对不同菜谱执行不同程序即可。

```
向右 x 步
拿起 1 个物品
向下 1 步
向左 x 步
放下 1 个物品
向上 1 步
向右 y 步
拿起 1 个物品
向下 1 步
向左 y 步
放下 1 个物品
```

自行修改 `x`, `y` = `1` or `2` 来控制不同菜谱即可。

## Level 1

写个简单循环，把物品不断放到锅中即可。

```
向右 1 步
拿起 100 个物品
向下 1 步
向左 1 步
放下 1 个物品
如果手上的物品大于等于 1 向上跳转 1 行
```

## Level 2

写 32 个程序，第 i 个程序分对应 `[0, 0, 0, 0, 0, i]` 这个菜谱。
然后再额外加一个程序，写 `向右 {} 步`，然后枚举数字，撞 hash（实际上是两个 sha256 和一个 arc4 随机?）。

# 灯，等灯等灯

## Level 0

解一个线性方程组即可。代码过丑就不放了（逃）。

~~我发现我不会写 % 256 意义下的高斯消元，于是我就直接用 Python 高精度，解完再取模。~~

~~然后我解完之后，没有去研究提交的 HTTP API，直接就写了个程序模拟鼠标点击（逃）~~

# Micro World

~~随便乱瞅一下（我不会告诉你我走了多少弯路的）~~，能发现这个程序是用 pyinstaller 生成的。

然后就找一个 pyinstaller unpacker（我用的是 [extremecoders-re/pyinstxtractor](https://github.com/extremecoders-re/pyinstxtractor)），然后就可以发现一个 `2.pyc` 文件。用 `pip` 安装 `pygame` 后，发现可以直接用 `python 2.pyc` 运行，能确定提取出了正确的东西。

接着继续尝试反编译，我这里找了 [zrax/pycdc](https://github.com/zrax/pycdc)，能够逆向 Python 3.9 的字节码，但不完全能逆向出来（但是至少能看到大致的逻辑，也能看到点的数据）。

这是 `2.pyc` 中 `Point` 的定义：

```python
class Point:
    def __init__(self, pos, vx, vy):
        (self.x, self.y) = pos
        self.vx = vx
        self.vy = vy
```

不难猜出，`vx` 和 `vy` 就是这个点的移动速度（也就是 `list_` 每个元素的后两个值）。显然，只要把这个速度取相反数就可以还原出原 flag 图案了（显然碰撞是可逆的）。

然而我并不想对着 bytecode 翻译一遍代码，所以我决定动态“注入”到 `2.pyc` 里面改变量。下面我们先把 `2.pyc` 重命名成 `w2.pyc`，因为不能直接 `import 2`。

但是 `import w2` 后，`import` 没返回，窗口已经运行了，有点难改变量。~~下面开始乱搞！~~

我们可以新建一个 `pygamx.py` 来 mock `pygame`，然后修改 `2.pyc` 的 bytecode：暴力把 `pygame` 改成 `pygamx`（暴力替换二进制数据即可）。

`pygamx.py`：

```python
'[TODO]'
```

然后经过测试，可以在上面 `pygame.time.Clock.tick` 里面反向 `import w2`，修改 `list_` 和 `Pointlist`，把速度取反，就可以了。

# 助记词

说句实话，这道题一点也不 math。

## 第一顿大餐

下载程序源码，打开。

其中 `cn.edu.ustc.lug.hack.mnemonic_phrase.Instance` 里的 `post` 是主要逻辑（flag 的处理也在这里），并且~~不难发现~~，这个函数里面有一个 for 循环，调试一下，发现每次请求好像只会循环一次。

回头看 HTTP API，发现似乎可以一次性提交一个数组，尝试一下提交 32 个相同的助记词，然后发现正好可以拿到第一个 flag。

## 第二顿大餐

~~作为一个逆向过 Minecraft 种子生成的人，怎么会止步于此呢~~

观察发现，`sleep` 函数是在 `Phrase.equals` 方法中执行的，然后我们并没有在本项目中发现直接调用它的地方。

再思考一下，能发现它会在 `Set<Phrase>`（实际上是 `LinkedHashSet`）中被 `Set` 调用。

第二个 flag 需要卡顿 9 秒，掐指一算，大概需要调用 `equals` 450 次，大概是 $n^2$ 的级别。

~~查看 `LinkedHashSet` 源代码~~，猜测一下，我们要构造 `hash` 相同的 `Phrase`，让 `Set` 进行 $n^2$ 级别次数的比较。

然后看 `Phrase.hash` 方法：

```java
@Override
public int hashCode() {
    return Objects.hash(this.text, this.time, this.user);
}
```

再看 [`Object.hash` 方法](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/util/Objects.java#l127)：

```java
public static int hash(Object... values) {
    return Arrays.hashCode(values);
}
```

再看 [`Arrays.hashCode` 方法](http://hg.openjdk.java.net/jdk8u/jdk8u/jdk/file/be44bff34df4/src/share/classes/java/util/Arrays.java#l4139)：

```java
public static int hashCode(Object a[]) {
    if (a == null) return 0;  // 在这个例子中与这个无关
    int result = 1;
    for (Object element : a)
        result = 31 * result + (element == null ? 0 : element.hashCode());
    return result;
}
```

换句话说，就是分别对 `this.text`, `this.time`, `this.user` 分别调用 `.hashCode()`，然后再拼在一起。这里先看 `this.text`（即 `String`）的 `hashCode`。

[`String.hashCode`](http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/String.java#l1452)：

```java
public int hashCode() {
    int h = hash;
    if (h == 0 && value.length > 0) {
        char val[] = value;
        for (int i = 0; i < value.length; i++)
            h = 31 * h + val[i];
        hash = h;
    }
    return h;
}
```

这个函数就是首先做了一个缓存，如果 `hash`（`String` 的一个 field）存在，就不算了。主要逻辑在 for 循环上。

我们可以把这个算法提取出来，暴力算 $600^4$ 种 hash（其实也可以双向 BFS，我这里没用）。

下面的暴力代码用 Rust 写，并且进行了一点小优化（因为算 `hashCode` 的过程是线性的），大概 5 分钟能跑完全部 $600^4$ 种 hash：

```rust
use std::collections::HashMap;
use std::num::Wrapping;

const MNEMONICS_TEXTS: [&str; 600] = [ ... ];
const POW_31: [u32; 15] = [ 1, 31, 961, 29791, 923521, 28629151, 887503681, 1742810335, 2487512833, 4098453791, 2498015937, 129082719, 4001564289, 3789408671, 1507551809 ];

// POW_31[i] 记录的是 pow(31, i) 的结果

struct Mnemonics {
    pow: u32,
    hash: u32,
}

fn hash_str(s: &str) -> u32 {
    let mut x = Wrapping(0);
    for c in s.chars() {
        x = x * Wrapping(31) + Wrapping(c as u32);
    }
    x.0
}

impl Mnemonics {
    pub fn new(_index: usize, text: &'static str) -> Mnemonics {
        Mnemonics {
            pow: POW_31[ text.len() ],
            hash: hash_str(text),
        }
    }
}

fn join_hash(ss: &[&Mnemonics]) -> u32 {
    let mut x = Wrapping(0);
    let mut first = true;
    for s in ss {
        if !first {
            x = x * Wrapping(31) + Wrapping(' ' as u32);
        }

        x = x * Wrapping(s.pow) + Wrapping(s.hash);

        first = false;
    }

    x.0
}

fn main() {
    let mut mnemonics = Vec::new();
    for (i, text) in MNEMONICS_TEXTS.iter().enumerate() {
        mnemonics.push(Mnemonics::new(i, text));
    }

    // 我们只收集 hashCode 为 [0, 20) 的
    // 这样取是没问题的，假设 hash 足够均匀的话
    const HASH_RANGE: u32 = 20;
    let mut result = HashMap::new();

    for hash in 0..HASH_RANGE {
        result.insert(hash, Vec::new());
    }

    for (i1, m1) in mnemonics.iter().enumerate() {
        for (i2, m2) in mnemonics.iter().enumerate() {
            for (i3, m3) in mnemonics.iter().enumerate() {
                for (i4, m4) in mnemonics.iter().enumerate() {
                    // 这个 \times 31 下面会提到
                    let hash = join_hash(&[&m1, &m2, &m3, &m4]).wrapping_mul(31);
                    if hash >= HASH_RANGE {
                        continue;
                    }

                    let plan = [i1, i2, i3, i4];
                    result.get_mut(&hash).unwrap().push(plan);
                }
            }
        }
    }

    println!("{:?}", result);
}
```

但是直接把暴力出的结果扔进程序里，发现最多只能卡 3 秒左右，是怎么回事？

我们继续看回去那个加单词的循环，把每一次循环所需的时间输出，就可以发现它的时间是 `24 - 49 - 71 - 103 - ... - 254 - 0 - 24 - 47 - ... - 243 - 0 - 23 - ...`（数字不是复制的，但是趋势是一样的）。

`Phrase.hash` 是 `Objects.hash(this.text, this.time, this.user);`，每过一秒，`this.time` 的变化就会使我们精心构造的 hash 冲突给毁掉。

这个有点难处理，观察回 `Arrays.hashCode`，我们可以把 `this.text.hashCode * 31` 后的 hash 缓存起来，每次当 `this.time` 加一的时候，我们就让 `this.text.hashCode * 31` 减一。

至于在这个长度为 32 的序列中，应该什么时候减一的这个问题，我也没有好的思路，只是随便试，试了一个相对较好的：

```python
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9 ]
```

由于实际运行时多微妙时间差（即开始运行的时候，并不是完全正对着每秒的开头的），所以要在在线的网站上多试几次。

# 密码生成器

运行密码生成器，发现并没有输入栏；并且能够感觉到，这道题是要“复现”输出。

然后，我们可以盲猜……这个程序的“输入”是，时间，精度大约是 1 秒。

然后的话，我们就可以把时间设置成 2021-09-22 23:11（也可以用 [RunAsDate](https://www.nirsoft.net/utils/run_as_date.html)）（感觉那个时区只是一个障眼法），然后生成一些密码，多试几个，就成了。

密码是 `$Z=CBDL7TjHu~mEX`，登入就能获取 flag 了。
